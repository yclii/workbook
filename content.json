{"meta":{"title":"李一称的博客","subtitle":"","description":"","author":"ycli","url":"https://yclii.github.io/workbook","root":"/workbook/"},"pages":[{"title":"关于","date":"2021-05-07T04:14:44.000Z","updated":"2021-10-27T11:13:08.611Z","comments":true,"path":"about/index.html","permalink":"https://yclii.github.io/workbook/about/index.html","excerpt":"","text":"关于我追求新技术，有代码洁癖，爱琢磨。 关于工作城市：武汉 关于学习一直在不停的学习中…近期学习方向：区块链 关于座右铭 Knowledge is the torch of wisdom.（知识是智慧的火炬） 关于爱好读书、动漫、篮球、静静"},{"title":"categories","date":"2021-05-06T18:45:28.000Z","updated":"2021-10-27T11:13:08.622Z","comments":true,"path":"categories/index.html","permalink":"https://yclii.github.io/workbook/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-05-06T20:25:35.000Z","updated":"2021-10-27T11:13:08.622Z","comments":true,"path":"tags/index.html","permalink":"https://yclii.github.io/workbook/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"gradle实战学习笔记","slug":"gradle实战学习笔记","date":"2022-01-07T15:08:59.000Z","updated":"2022-01-07T02:43:12.834Z","comments":true,"path":"2022/01/07/gradle实战学习笔记/","link":"","permalink":"https://yclii.github.io/workbook/2022/01/07/gradle%E5%AE%9E%E6%88%98%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"groovy程序设计学习笔记","slug":"groovy程序设计学习笔记","date":"2022-01-07T15:07:29.000Z","updated":"2022-01-07T02:42:18.821Z","comments":true,"path":"2022/01/07/groovy程序设计学习笔记/","link":"","permalink":"https://yclii.github.io/workbook/2022/01/07/groovy%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Kettle构建Hadoop_ETL系统实践","slug":"Kettle构建Hadoop-ETL系统实践","date":"2022-01-07T15:03:45.000Z","updated":"2022-01-13T03:39:23.029Z","comments":true,"path":"2022/01/07/Kettle构建Hadoop-ETL系统实践/","link":"","permalink":"https://yclii.github.io/workbook/2022/01/07/Kettle%E6%9E%84%E5%BB%BAHadoop-ETL%E7%B3%BB%E7%BB%9F%E5%AE%9E%E8%B7%B5/","excerpt":"","text":"1. ETL与Kettle1.1 ETL ETL，抽取、转换、装载 数据仓库架构中的ETL RDS：原始数据存储 TDS：转换后数据存储 ODS：操作型数据存储；RDS实际上起到了ODS的作用 数据目录：元数据存储，提供数据仓库中的数据清单 1.2 Kettle Kettle，基于引擎架构、java语言开发的可视化、低代码ETL工具 2. Kettle安装1234567891011121314151617181920212223242526272829303132333435# 下载安装包wget https://sourceforge.net/projects/pentaho/files/Pentaho-9.2/client-tools/pdi-ce-9.2.0.0-290.zip# 解压# 解压后的文件夹data-integrationunzip pdi-ce-9.2.0.0-290.zip# 权限转移sudo chown 当前用户:当前用户所属组 /opt/data-integration# 调整jdk版本，安装openjdk1.8，已解决jdk11不支持java.endorsed.dirs的问题dnf install java-1.8.0-openjdk.x86_64# 调整版本sudo alternatives --config java# 设置JAVA_HOMEvi ~/.bash_profile# 添加 export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.312.b07-2.fc34.x86_64/jre# 安装redhat-lsb-corednf install redhat-lsb-core# 修改spoon.sh# 查询webkitgtk版本ldconfig -p|grep webkit# 将HASWEBKITGTK=`$LDCONFIG -p | grep webkitgtk-1.0`#修改为HASWEBKITGTK=`$LDCONFIG -p | grep webkit2gtk`# 添加spoon桌面快捷图标sudo vi /usr/share/applications/kettle-spoon.desktop# 添加以下内容[Desktop Entry]Name=Spoon Comment=Kettle SpoonExec=/opt/data-integration/spoon.shIcon=/opt/data-integration/spoon.icoTerminal=falseType=ApplicationCategories=Application;Development;StartupNotify=true 3. Kettle配置 KETTLE_HOME 若没有设置KETTLE_HOME环境变量，则Kettle的默认目录为~/.kettle 配置文件 Kettle的几个配置文件：.spoonrc、jdbc.properties、kettle.properties、kettle.pwd、repositories.xml、shared.xml 配置文件 目录 说明 .spoonrc KETTLE_HOME spoon图形界面配置参数，如窗口外观配置等 jdbc.properties 安装目录/simple-jndi jndi连接信息 kettle.properties KETTLE_HOME 全局属性配置，转换或作业通过${属性名}或%%属性名%%引用。此外，还可以设置一些预定义变量，如：KETTLE_REPOSITORY 默认的资源库；KETTLE_USER 资源库用户名；KETTLE_PASSWORD 资源库密码","categories":[],"tags":[]},{"title":"Linux软件安装工具","slug":"Linux软件安装工具","date":"2022-01-07T06:27:42.000Z","updated":"2022-01-07T07:42:32.292Z","comments":true,"path":"2022/01/07/Linux软件安装工具/","link":"","permalink":"https://yclii.github.io/workbook/2022/01/07/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%B7%A5%E5%85%B7/","excerpt":"","text":"apt-getapt-get，高级包装工具（Advanced Packaging Tools）是Debian及其衍生发行版（如：ubuntu）的软件包管理器。APT可以自动下载，配置，安装二进制或者源代码格式的软件包，因此简化了Unix系统管理软件的过程。 语法 1apt-get(命令)(选项) 命令 12345678910111213update - 重新获取软件包列表 upgrade - 进行更新 install - 安装新的软件包 remove - 移除软件包 autoremove - 自动移除全部不使用的软件包 purge - 移除软件包和配置文件 source - 下载源码档案 build-dep - 为源码包配置编译依赖 dist-upgrade - 发行版升级dselect-upgrade - 依照 dselect 的选择更新 clean - 清除下载的归档文件 autoclean - 清除旧的的已下载的归档文件 check - 检验是否有损坏的依赖 选项 123456789101112-h 本帮助文件。 -q 输出到日志 - 无进展指示 -qq 不输出信息，错误除外 -d 仅下载 - 不安装或解压归档文件 -s 不实际安装。模拟执行命令-y 假定对所有的询问选是，不提示 -f 尝试修正系统依赖损坏处 -m 如果归档无法定位，尝试继续-u 同时显示更新软件包的列表 -b 获取源码包后编译 -V 显示详细的版本号-c=? 阅读此配置文件-o=? 设置自定的配置选项，如 -o dir::cache=/tmp 实例 使用apt-get命令的第一步就是引入必需的软件库，Debian的软件库也就是所有Debian软件包的集合，它们存在互联网上的一些公共站点上。把它们的地址加入，apt-get就能搜索到我们想要的软件。/etc/apt/sources.list是存放这些地址列表的配置文件，其格式如下： 1deb web或[ftp地址] [发行版名字] main/contrib/non-[free] 在修改/etc/apt/sources.list或者/etc/apt/preferences之后运行该命令。此外您需要定期运行这一命令以确保您的软件包列表是最新的： 1apt-get update 安装一个新软件包： 1apt-get install packagename 卸载一个已安装的软件包（保留配置文件）： 1apt-get remove packagename 卸载一个已安装的软件包（删除配置文件）： 1apt-get –purge remove packagename 会把已装或已卸的软件都备份在硬盘上，所以如果需要空间的话，可以让这个命令来删除你已经删掉的软件： 1apt-get autoclean apt 这个命令会把安装的软件的备份也删除，不过这样不会影响软件的使用的： 1apt-get clean 更新所有已安装的软件包： 1apt-get upgrade 将系统升级到新版本： 1apt-get dist-upgrade 定期运行这个命令来清除那些已经卸载的软件包的.deb文件。通过这种方式，您可以释放大量的磁盘空间。如果您的需求十分迫切，可以使用apt-get clean以释放更多空间。这个命令会将已安装软件包裹的.deb文件一并删除。大多数情况下您不会再用到这些.debs文件，因此如果您为磁盘空间不足而感到焦头烂额，这个办法也许值得一试： 1apt-get autoclean apt-fileapt-file是一个软件包查找工具，可以查到软件包所含的文件和安装的位置。 123456# 安装apt-fileapt-get install apt-file# 更新apt-file缓存apt-file update# 查看帮助apt-file -h apt-cache通过apt-cache命令结合一些参数使用能查寻到软件包信息和软件包依赖关系 1234# 安装apt-cacheapt-get install apt-cache# 查看帮助apt-cache -h 常用命令 apt-cache的常用命令： showsrc - 显示源文件的各项记录 search - 根据正则表达式搜索软件包列表 depends - 显示该软件包的依赖关系信息 rdepends - 显示所有依赖于该软件包的软件包名字 show - 以便于阅读的格式介绍该软件包 pkgnames - 列出所有软件包的名字 policy - 显示软件包的安装设置状态 实例 1234# 查看火狐apt-cache show firefox# 查看依赖apt-cache rdepends firefox aptitudeaptitude与 apt-get 一样，是 Debian 及其衍生系统中功能极其强大的包管理工具。与 apt-get 不同的是，aptitude在处理依赖问题上更佳一些。如aptitude在删除一个包时，会同时删除本身所依赖的包。 12apt-get install aptitudeaptitude -h yumYUM（Yellowdog Updater Modified）是一款开源命令行及图形化软件包管理工具，面向基于RPM（红帽软件包管理器）的Linux系统。它让广大用户和系统管理员可以在系统上轻松地安装、更新、移除或搜索软件包。它由Seth Vidal开发和发布，采用了GPL（通用公共许可证），是一款开源工具。这意味着，谁都可以下载和访问代码，以修复软件错误，开发定制的软件包。YUM通过解决软件包的依赖项问题，使用众多的第三方软件库来自动安装软件包。 查看语法 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879yum -h已加载插件：fastestmirror, langpacksUsage: yum [options] COMMANDList of Commands:check 检查 RPM 数据库问题check-update 检查是否有可用的软件包更新clean 删除缓存数据deplist 列出软件包的依赖关系distribution-synchronization 已同步软件包到最新可用版本downgrade 降级软件包erase 从系统中移除一个或多个软件包fs Creates filesystem snapshots, or lists/deletes current snapshots.fssnapshot Creates filesystem snapshots, or lists/deletes current snapshots.groups 显示或使用、组信息help 显示用法提示history 显示或使用事务历史info 显示关于软件包或组的详细信息install 向系统中安装一个或多个软件包langavailable Check available languageslanginfo List languages informationlanginstall Install appropriate language packs for a languagelanglist List installed languageslangremove Remove installed language packs for a languagelist 列出一个或一组软件包load-transaction 从文件名中加载一个已存事务makecache 创建元数据缓存provides 查找提供指定内容的软件包remove 删除软件包及依赖reinstall 覆盖安装软件包repo-pkgs 将一个源当作一个软件包组，这样我们就可以一次性安装/移除全部软件包。repolist 显示已配置的源search 在软件包详细信息中搜索指定字符串shell 运行交互式的 yum shellswap Simple way to swap packages, instead of using shellupdate 更新系统中的一个或多个软件包update-minimal Works like upgrade, but goes to the &#x27;newest&#x27; package match which fixes a problem that affects your systemupdateinfo Acts on repository update informationupgrade 更新软件包同时考虑软件包取代关系version 显示机器和/或可用的源版本。Options: -h, --help 显示此帮助消息并退出 -t, --tolerant 忽略错误 -C, --cacheonly 完全从系统缓存运行，不升级缓存 -c [config file], --config=[config file] 配置文件路径 -R [minutes], --randomwait=[minutes] 命令最长等待时间 -d [debug level], --debuglevel=[debug level] 调试输出级别 --showduplicates 在 list/search 命令下，显示源里重复的条目 -e [error level], --errorlevel=[error level] 错误输出级别 --rpmverbosity=[debug level name] RPM 调试输出级别 -q, --quiet 静默执行 -v, --verbose 详尽的操作过程 -y, --assumeyes 回答全部问题为是 --assumeno 回答全部问题为否 --version 显示 Yum 版本然后退出 --installroot=[path] 设置安装根目录 --enablerepo=[repo] 启用一个或多个软件源(支持通配符) --disablerepo=[repo] 禁用一个或多个软件源(支持通配符) -x [package], --exclude=[package] 采用全名或通配符排除软件包 --disableexcludes=[repo] 禁止从主配置，从源或者从任何位置排除 --disableincludes=[repo] disable includepkgs for a repo or for everything --obsoletes 更新时处理软件包取代关系 --noplugins 禁用 Yum 插件 --nogpgcheck 禁用 GPG 签名检查 --disableplugin=[plugin] 禁用指定名称的插件 --enableplugin=[plugin] 启用指定名称的插件 --skip-broken 忽略存在依赖关系问题的软件包 --color=COLOR 配置是否使用颜色 --releasever=RELEASEVER 在 yum 配置和 repo 文件里设置 $releasever 的值 --downloadonly 仅下载而不更新 --downloaddir=DLDIR 指定一个其他文件夹用于保存软件包 --setopt=SETOPTS 设置任意配置和源选项 --bugfix Include bugfix relevant packages, in updates --security Include security relevant packages, in updates --advisory=ADVS, --advisories=ADVS Include packages needed to fix the given advisory, in updates --bzs=BZS Include packages needed to fix the given BZ, in updates --cves=CVES Include packages needed to fix the given CVE, in updates --sec-severity=SEVS, --secseverity=SEVS Include security relevant packages matching the severity, in updates 实例 12345678910# 查看火狐依赖yum deplist firefox# 删除firefox及依赖yum remove firefox# 列出系统所有已启用的软件库yum repolist# 查看历史命令yum history# 从软件库中搜索yum search firefox 添加yum源 123456789# 备份操作系统自带的基础源mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup# 下载对应版本repo文件, 放入/etc/yum.repos.d/(操作前请做好相应备份)# 除了网易之外，国内还有其他不错的yum源，比如中科大和搜狐。wget http://mirrors.163.com/.help/CentOS5-Base-163.repowget http://mirrors.163.com/.help/CentOS6-Base-163.repo# 刷新缓存yum clean allyum makecache dnfDNF是新一代的rpm软件包管理器。他首先出现在 Fedora 18 这个发行版中。而最近，它取代了yum，正式成为 Fedora 22 的包管理器。DNF包管理器克服了YUM包管理器的一些瓶颈，提升了包括用户体验，内存占用，依赖分析，运行速度等多方面的内容。DNF使用 RPM, libsolv 和 hawkey 库进行包管理操作。尽管它没有预装在 CentOS 和 RHEL 7 中，但你可以在使用 YUM 的同时使用 DNF 。 为了安装 DNF ，必须先安装并启用 epel-release 依赖。 1yum install epel-release -y 使用 epel-release 依赖中的 YUM 命令来安装 DNF 包。在系统中执行以下命令： 1yum install dnf 查看 DNF 包管理器版本 1dnf –version 查看系统中可用的 DNF 软件库 1dnf repolist 查看系统中可用和不可用的所有的 DNF 软件库 1dnf repolist all 列出所有 RPM 包 用处：该命令用于列出用户系统上的所有来自软件库的可用软件包和所有已经安装在系统上的软件包 1dnf list 列出所有安装了的 RPM 包 用处：该命令用于列出所有安装了的 RPM 包 1dnf list installed 列出所有可供安装的 RPM 包 用处：该命令用于列出来自所有可用软件库的可供安装的软件包 1dnf list available 搜索软件库中的 RPM 包 用处：当你不知道你想要安装的软件的准确名称时，你可以用该命令来搜索软件包。你需要在”search”参数后面键入软件的部分名称来搜索。（在本例中我们使用”nano”） 1dnf search nano 查找某一文件的提供者 用处：当你想要查看是哪个软件包提供了系统中的某一文件时，你可以使用这条命令。（在本例中，我们将查找”/bin/bash”这个文件的提供者） 1dnf provides /bin/bash 查看软件包详情 用处：当你想在安装某一个软件包之前查看它的详细信息时，这条命令可以帮到你。（在本例中，我们将查看”nano”这一软件包的详细信息） 1dnf info nano 安装软件包 用处：使用该命令，系统将会自动安装对应的软件及其所需的所有依赖（在本例中，我们将用该命令安装nano软件） 1dnf install nano 升级软件包 用处：该命令用于升级制定软件包（在本例中，我们将用命令升级”systemd”这一软件包） 1dnf update systemd 检查系统软件包的更新 用处：该命令用于检查系统中所有软件包的更新 1dnf check-update 升级所有系统软件包 用处：该命令用于升级系统中所有有可用升级的软件包 12dnf update # 或 dnf upgrade 删除软件包 用处：删除系统中指定的软件包（在本例中我们将使用命令删除”nano”这一软件包） 12dnf remove nano# 或 dnf erase nano 删除无用孤立的软件包 用处：当没有软件再依赖它们时，某一些用于解决特定软件依赖的软件包将会变得没有存在的意义，该命令就是用来自动移除这些没用的孤立软件包。 1dnf autoremove 删除缓存的无用软件包 用处：在使用 DNF 的过程中，会因为各种原因在系统中残留各种过时的文件和未完成的编译工程。我们可以使用该命令来删除这些没用的垃圾文件。 1dnf clean all 获取有关某条命令的使用帮助 用处：该命令用于获取有关某条命令的使用帮助（包括可用于该命令的参数和该命令的用途说明）（本例中我们将使用命令获取有关命令”clean”的使用帮助） 1dnf help clean 查看所有的 DNF 命令及其用途 用处：该命令用于列出所有的 DNF 命令及其用途shell 1dnf help 查看 DNF 命令的执行历史 用处：您可以使用该命令来查看您系统上 DNF 命令的执行历史。通过这个手段您可以知道在自您使用 DNF 开始有什么软件被安装和卸载。 1dnf history 查看所有的软件包组 用处：该命令用于列出所有的软件包组 1dnf grouplist 安装一个软件包组 用处：该命令用于安装一个软件包组（本例中，我们将用命令安装”Educational Software”这个软件包组） 1dnf groupinstall ‘Educational Software’ 升级一个软件包组中的软件包 用处：该命令用于升级一个软件包组中的软件包（本例中，我们将用命令升级”Educational Software”这个软件包组中的软件） 1dnf groupupdate ‘Educational Software’ 删除一个软件包组 用处：该命令用于删除一个软件包组（本例中，我们将用命令删除”Educational Software”这个软件包组） 1dnf groupremove ‘Educational Software’ 从特定的软件包库安装特定的软件 用处：该命令用于从特定的软件包库安装特定的软件（本例中我们将使用命令从软件包库 epel 中安装 phpmyadmin 软件包） 1dnf –enablerepo=epel install phpmyadmin 更新软件包到最新的稳定发行版 用处：该命令可以通过所有可用的软件源将已经安装的所有软件包更新到最新的稳定发行版 1dnf distro-sync 重新安装特定软件包 用处：该命令用于重新安装特定软件包（本例中，我们将使用命令重新安装”nano”这个软件包） 1dnf reinstall nano 回滚某个特定软件的版本 用处：该命令用于降低特定软件包的版本（如果可能的话）（本例中，我们将使用命令降低”acpid”这个软件包的版本） 1dnf downgrade acpid 样例输出： 123Using metadata from Wed May 20 12:44:59 2015No match for available package: acpid-2.0.19-5.el7.x86_64Error: Nothing to do.shell 原作者注：在执行这条命令的时候， DNF 并没有按照我期望的那样降级指定的软件（“acpid”）。该问题已经上报。 总结 DNF 包管理器作为 YUM 包管理器的升级替代品，它能自动完成更多的操作。但在我看来，正因如此，所以 DNF 包管理器不会太受那些经验老道的 Linux 系统管理者的欢迎。举例如下： 在 DNF 中没有 –skip-broken 命令，并且没有替代命令供选择。 在 DNF 中没有判断哪个包提供了指定依赖的 resolvedep 命令。 在 DNF 中没有用来列出某个软件依赖包的 deplist 命令。 当你在 DNF 中排除了某个软件库，那么该操作将会影响到你之后所有的操作，不像在 YUM 下那样，你的排除操作只会咋升级和安装软件时才起作用。 文档说明文档内容均摘自网络 《linux工具apt、yum和dnf运用》 https://www.cnblogs.com/qvduoduo/p/6148523.html 《Linux命令大全-dnf 》https://ipcmen.com/dnf 《Linux命令大全-yum 》https://ipcmen.com/yum","categories":[],"tags":[]},{"title":"深入浅出https从原理到实践学习笔记","slug":"深入浅出https从原理到实践学习笔记","date":"2021-12-29T19:32:40.000Z","updated":"2022-01-03T08:18:19.914Z","comments":true,"path":"2021/12/29/深入浅出https从原理到实践学习笔记/","link":"","permalink":"https://yclii.github.io/workbook/2021/12/29/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAhttps%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1. HTTP介绍1.1 几个概念 web(万维网)，是互联网的一个子应用，主要包括3项技术：HTML、URL、HTTP HTTP(超文本传输协议)，由一系列规则组成，客户端和服务端共同处理这些规则，HTTP不仅定义规则，也是信息的载体 URL(统一资源标识符)，可唯一定位或标识互联网上的任何资源 HTML(超文本标记语言)，客户端(浏览器)通过HTTP接收的资源一般是HTML，HTML定义了一系列规则，规则主要有客户端进行解析。 1.2 HTTP版本目前版本HTTP/1.1，基于RFC2616规范，相比HTTP/0.9、HTTP/1.0，HTTP/1.1并没有太多的演变，但从性能和标准化的维度做了些优化；HTTP/2.0是下一代标准。 1.2 HTTP语义 HTTP消息包括HTTP语义和HTML实体 HTTP消息包括3部分：请求行或响应行、HTTP头部（可以多个）、HTML实体(请求实体和响应实体) 请求行由方法、URL、HTTP版本组成（如：GET /index.html HTTP/1.1）；响应行由HTTP版本、状态码、信息提示符组成（如：HTTP/1.1 200 OK） HTTP语义的重点是HTTP头部(HTTP Header)，约束客户端或服务端行为（如Accept-Encoding:gzip，表示浏览器支持的数据压缩算法是gzip，告诉服务器是否可以使用gzip算法压缩响应；Host:www.baidu.com，该头部只对客户端有用，客户端在连接前需要通过DNS解析出IP地址，然后连接服务器发送请求） 1.3 HTTP特点 HTTP特点：无状态、跨平台 HTTP协议处于网络模型的应用层，默认端口80 1.4 HTTP不安全原因HTTP在设计之处根本没有考虑安全问题，其设计目的是数据传输与共享。 HTTP不安全的原因主要包括以下3点： 数据没有加密 无法验证身份 数据易篡改 1.5 攻击方式​ SQL注入、XSS、Dos(DDos) 1.6 缓解安全问题的措施W3C制定Web技术标准，如HTML标准、DOM标准、CSS标准、ECMAScript标准、HTML5标准。 W3C主要以HTTP头部的方式提供安全保护，以缓解安全问题，如Access-Control-Allow-Origin、X-XSS-Protection、Strict-Transport-Security、Content-Security-Policy等等，如XSS攻击，服务器声明头部Content-Security-Policy，告诉浏览器只允许加载本域下的脚本文件，就能避免跨站脚本攻击。 2. 密码学HTTPS的本质就是对密码学算法的组合使用 2.1 密码学的四个目标 机密性(隐私性) 完整性 身份验证 不可抵赖性 2.2 OpenSSLOpenSSL是密码学中一个非常流行的底层密码库，封装了所有密码学算法、证书管理、TLS/SSL协议实现。 包含两种类型的库： crypto库函数，具体的密码学算法使用库，如MD5、RSA、DES等 EVP接口，高层次库，基于crypto库函数进一步封装，便于开发者调用 查看OpenSSL版本 1openssl version 查看所有支持的命令 1openssl help 获取算法的帮助信息 1openssl rsa --help 获取算法详细使用信息 1man rsa 显示系统支持的加密算法 1openssl list --cipher-algorithms 构建特定版本的openssl 1234567891011121314151617# 示例：构建OpenSSL-1.1.0f，避免和系统的OpenSSL库冲突# 下载二进制包并解压wget https://www.openssl.org/source/openssl-1.1.0f.tar.gztar -xvf openssl-1.1.0f.tar.gzcd openssl-1.1.0f# 查看安装手册more INSTALL# 查看config./config --help# 安装并编译，安装目录不要和系统目录冲突（可以查看系统的安装目录 which openssl）./config --prefix=/usr/local/openssl --openssldir=/usr/local/opensslmakemake testmake installmake clean# 验证/usr/local/openssl/bin/openssl version 2.3 随机数 随机数生成器评判的4个指标 效率 在短时间内生成大量的随机数 随机性 生成的随机数只要不存在统计学偏差，就说明具备随机性 不可预测性 随机数之间存在一定的关联，如通过以前的随机数推断出后续的随机数，说明不具备不可预测性。 密码学中的随机数必须具备不可预测性 不可重现性 不管经过多长时间，不会产生完全相同的随机数 随机数类型 名称 生成类型 特性 说明 真正的随机数生成器(TRNG) 硬件生成 效率高、随机性、不可预测性、不可重现性 需要从物理设备获取 伪随机数生成器(PRNG) 软件生成 效率高、随机性 通过算法获取 密码学伪随机数生成器(CPRNG) 软件生成 效率高、随机性、不可预测性 通过密码学算法获取 随机数生成器原理 随机数生成器内部维护一个状态，对于TRNG，内部状态值来自硬件设备，称为熵(entrory)，比如动态的时间、变化的温度、鼠标位置等；对于PRNG、CPRNG，内部状态值来自模拟的数值，称为种子(seed)。 每次生成随机数，熵或种子都会变化，这样产生的随机数就不一样；若每次熵或种子是一样的，生成的随机数也是相同的。 常见的随机数生成器 使用外部熵生成随机数 1head -c 32 /dev/urandom | openssl enc -base64 伪随机数生成器(算法) Blum Blum Shub、Mersenne Twister(马特赛特旋转演算法)、Linear congruential generator(线性同余法) 密码学随机数生成器(算法) 块密码算法CTR模式、摘要算法、流密码算法 产生的随机数有：密钥、初始化向量(IV)、nonce、salt 2.4 密码学Hash算法 公式 摘要/散列值/指纹=hash(消息) 特点 不管消息长度多少，最终的摘要值长度是相同的 相同的消息总是能得到相同的摘要值 不管多长的消息，hash算法非常快速 单向性，通过摘要值很难逆向计算原始消息 原始消息一旦修改，最终的摘要值也会产生变化 基于hash算法的密码学算法 算法名称 说明 伪随机数生成器 利用密码学hash算法单向性，可以构造随机数 MAC消息验证码 HMAC就是基于密码学hash算法实现的MAC算法 基于口令的加密算法 通过口令和密码学hash算法生成密钥 数字签名 数字签名算法对密码学hash算法生成的摘要进行签名 块密钥加密算法 基于密码学hash算法能生成块密钥加密算法，同时块密钥加密算法也能生成一个密码学hash算法 实际用途 文件比较、身份(口令)验证等 密码学hash算法和hash算法 密码学hash算法拥有hash算法的所有特性，从安全的角度，密码学hash算法还有其他特性；基于普通hash算法实现的应用，如hash表、校验和却不能用于密码学 基于安全的特性 强抗碰撞性 若两个不相同的值能够得到同样的摘要值，表示产生了hash碰撞，此时违反强抗碰撞性 弱抗碰撞性 若给定一个消息以及这个消息的摘要值，能找到一条不同的消息也具有相同的摘要值，此时违反弱抗碰撞性 单向性 若给定一个摘要值能计算出原始消息，此时违反单向性 破解难度：强抗碰撞性 &lt; 弱抗碰撞性 &lt; 单向性 分类 MD5(目前证明已不安全)、SHA族类算法 分类算法输入值最大长度(bit)输出值长度(bit)说明 MD5MD5无限制128实践中已违反硬抗碰撞性，且理论上也不具备弱抗碰撞性 SHA-1SHA-12^64-1160实践中已违反硬抗碰撞性 SHA-2SHA-2562^64-1256安全使用 SHA-5122^128-1512安全使用 SHA-2242^64-1224安全使用 SHA-3842^128-1384安全使用 SHA-3SHA3-2562^64-1256安全使用 SHA3-5122^128-1512安全使用 SHA3-2242^64-1224安全使用 SHA3-3842^128-1384安全使用 2.5 数据加密 分类 对称加密算法、非对称加密算法（即公开加密算法） 2.5.1 对称加密算法 密钥是一串数字，加密和解密使用同一个密钥 加密和解密是一个互逆过程 对称加密算法包括：块密码算法、流密码算法 分类算法密钥长度(bit)分组长度(bit)说明 块密码AES128、192、256128对称加密算法的标准算法 DES5664早期对称加密算法标准 3DES128、16864三重DES算法 IDEA算法128、192、256128不太常见的算法 SEED算法128128不太常见的算法 分类算法密钥长度(bit)说明 流密码RC4可变密钥长度，建议2048已证明不安全 ChaCha可变密钥长度，建议256一种新型的流密码算法 块密码算法 对固定长度（即分组长度）的数据块进行迭代处理，得到的密文长度和明文长度相同 块密码的迭代模式包括：ECB、CBC、CTR ECB模式： 加解密每个数据块的密钥都相同；可并行加解密数据块；若固定的明文，因密钥也是固定的，很容易造成安全问题 加密： graph TD subgraph 数据块n plainn[明文]-->encoden[加密] keyn[密钥]-->encoden[加密] encoden[加密]-->ciphern[密文] end subgraph 数据块2 plain2[明文]-->encode2[加密] key2[密钥]-->encode2[加密] encode2[加密]-->cipher2[密文] end subgraph 数据块1 plain1[明文]-->encode1[加密] key1[密钥]-->encode1[加密] encode1[加密]-->cipher1[密文] end 解密： graph TD subgraph 数据块n ciphern[密文]-->decoden[解密] keyn[密钥]-->decoden[解密] decoden[解密]-->plainn[明文] end subgraph 数据块2 cipher2[密文]-->decode2[解密] key2[密钥]-->decode2[解密] decode2[解密]-->plain2[明文] end subgraph 数据块1 cipher1[密文]-->decode1[解密] key1[密钥]-->decode1[解密] decode1[解密]-->plain1[明文] end CBC模式： 首先需生成随机的初始化向量IV，长度等于分组长度；运算不能并行处理 加密： graph LR cipher2[密文]-->xorn[XOR结果] subgraph 数据块n plainn[明文]-->xorn[XOR结果] keyn[密钥]-->encoden[加密] xorn[XOR结果]-->encoden[加密] encoden[加密]-->ciphern[密文] end cipher1[密文]-->xor2[XOR结果] subgraph 数据块2 plain2[明文]-->xor2[XOR结果] key2[密钥]-->encode2[加密] xor2[XOR结果]-->encode2[加密] encode2[加密]-->cipher2[密文] end subgraph 数据块1 plain1[明文]-->xor1[XOR结果] IV1[IV]-->xor1[XOR结果] key1[密钥]-->encode1[加密] xor1[XOR结果]-->encode1[加密] encode1[加密]-->cipher1[密文] end 解密： graph LR decode2[解密]-->xorn[XOR] subgraph 数据块n ciphern[密文]-->decoden[解密] keyn[密钥]-->decoden[解密] decoden[解密]-->xorn[XOR] xorn-->plainn[明文] end decode1[解密]-->xor2[XOR] subgraph 数据块2 cipher2[密文]-->decode2[解密] key2[密钥]-->decode2[解密] decode2[解密]-->xor2[XOR] xor2-->plain2[明文] end subgraph 数据块1 cipher1[密文]-->decode1[解密] key1[密钥]-->decode1[解密] decode1[解密]-->xor1[XOR] IV1[IV]-->xor1[XOR] xor1-->plain1[明文] end CTR模式： 首选为每个数据块需生成随机的密钥流，密钥流之间有关联关系，最简单的是密钥流递增方式，则只需生成第一块的密钥流（后续数据块递增推导），此时也叫做计数器模式；分组不需要填充；可并行加解密数据块 加密： graph TD subgraph 数据块n noncen[\"nonce(n-1)\"]-->encoden[加密] keyn[密钥]-->encoden[加密] plainn[明文]-->xorn[XOR] encoden[加密]-->xorn[XOR] xorn[XOR]-->ciphern[密文] end subgraph 数据块2 nonce2[\"nonce(1)\"]-->encode2[加密] key2[密钥]-->encode2[加密] plain2[明文]-->xor2[XOR] encode2[加密]-->xor2[XOR] xor2[XOR]-->cipher2[密文] end subgraph 数据块1 nonce1[\"nonce(0)\"]-->encode1[加密] key1[密钥]-->encode1[加密] plain1[明文]-->xor1[XOR] encode1[加密]-->xor1[XOR] xor1[XOR]-->cipher1[密文] end 解密： graph TD subgraph 数据块n noncen[\"nonce(n-1)\"]-->encoden[加密] keyn[密钥]-->encoden[加密] ciphern[密文]-->xorn[XOR] encoden[加密]-->xorn[XOR] xorn[XOR]-->plainn[明文] end subgraph 数据块2 nonce2[\"nonce(1)\"]-->encode2[加密] key2[密钥]-->encode2[加密] cipher2[密文]-->xor2[XOR] encode2[加密]-->xor2[XOR] xor2[XOR]-->plain2[明文] end subgraph 数据块1 nonce1[\"nonce(0)\"]-->encode1[加密] key1[密钥]-->encode1[加密] cipher1[密文]-->xor1[XOR] encode1[加密]-->xor1[XOR] xor1[XOR]-->plain1[明文] end 对称加密实践 123456789touch aes.txtecho &quot;hello aes&quot; &gt; aes.txt# 此时aes的密钥是通过口令和salt生成的；# 同样的口令和salt会生成同样的密钥；salt是随机的，以保证每次的密钥不同# -p 打印本次加密过程# 查询系统支持的加密算法：openssl list --cipher-algorithmsopenssl enc -aes-256-cbc -salt -in aes.txt-out aes.enc -pass pass:mypassword -p #解密openssl enc -d -aes-256-cbc -in aes.enc 2.5.1 公开密钥算法公开密钥算法也称为非对称加密算法 和对称加密算法的比较 对称加密算法主要用于加解密，但公开密钥算法除了加解密，还可以做密钥协商、数字签名。 密钥是一对，公钥和私钥 运算很慢，加解密要考虑运算数据量 RSA算法 加解密： graph LR plain[明文]-->encode[加密] pubkey[公钥]-->encode[加密] encode[加密]-->cipher[密文] cipher[密文]-->decode[解密] prikey[私钥]-->decode[解密] decode[解密]-->plain2[明文] 加解密剖析： 公钥和私钥一般以文件形式提供 密钥文件生成过程： 取2个很大的质数p、q，求乘积n=p*q 取一个公开指数e，e &lt; (p-1)(q-1)，且e和(p-1)(q-1)互质 e和n组合起来就相当于公钥；e、p、q能够计算出私钥d，d和n组合起来就相当于私钥 C=M^e(mod n)，M表示明文，e表示公钥，C表示密文；M=C^d(mod n)，d表示私钥 PKCS标准： 公开密钥算法的标准PKCS(Public Key Cryptography Standards)，指导使用者正确使用公开密钥算法。 如PKCS#1标准，能够保证同样的明文、同样的密钥，通过RSA加密，每次的密文都是不一样的。 应用场景： 单步加密 客户端第一次连接服务器，服务器返回RSA密钥对的公钥 客户端用公钥加密，发给服务器 服务器用私钥解密 双向加密 客户端生成一对RSA密钥对，连接服务器并发送公钥(cpubkey) 服务器保存客户端公钥，并生成另一对RSA密钥对，并将自己的公钥(spubkey)发给客户端 客户端使用服务端的公钥加密，服务器收到后，用自己的私钥(sprikey)解密，然后用客户端的公钥加密返回信息 客户端使用自己的私钥(cprikey)解密 公开密钥实践 12345678910111213141516171819202122232425# 生成密钥对文件openssl genrsa -out rsa.pem 2048# 生成密钥对文件，同时用3des算法进行保护# 3des算法的密钥是通过口令生成的openssl genrsa -des3 -out rsa2.pem 2048# 校验密码对文件是否正确# -noout，表示不打印密钥对信息openssl rsa -in rsa.pem -check -noout# 分离出公钥openssl rsa -in rsa.pem -pubout -out rsapubkey.pem# 分离出公钥，但需要输入口令openssl rsa -in rsa2.pem -pubout -out rsapubkey2.pem# 显示公钥信息openssl rsa -pubin -in rsapubkey.pem -text# 加密touch rsa.txtecho &quot;hello rsa&quot; &gt; rsa.txt#使用密钥对加密openssl rsautl -encrypt -inkey rsa.pem -in rsa.txt -out rsa.enc#使用公钥加密openssl rsautl -encrypt -pubin -inkey rsapubkey.pem -in rsa.txt -out rsa.enc#解密openssl rsautl -decrypt -inkey rsa.pem -in rsa.enc 2.6 消息验证码 消息验证码(Message Authentication Code，MAC)用于消息防止篡改 通信双方维护同一个密钥，MAC值=mac(消息, 密钥) graph LR macv1[MAC值]-.->|发送并比较|macv2[MAC值] msg1[消息]-.->|发送|msg2[消息] subgraph 接收方 key2[密钥]-->mac2[MAC运算] msg2[消息]-->mac2[MAC运算] mac2[MAC运算]-->macv2[MAC值] end subgraph 发送方 msg1[消息]-->mac1[MAC运算] key1[密钥]-->mac1[MAC运算] mac1[MAC运算]-->macv1[MAC值] end MAC算法种类 有2种形式，CBC-MAC、HMAC CBC-MAC，从块密码算法的CBC分组模式演变而来，最后一个密文分组就是MAC值 HMAC，以Hash算法为加密基元，包括HMAC-SHA-1、HMAC-SHA256、HMAC-SHA512等 MAC算法实践 123456touch hmac.txtecho &quot;hello hmac&quot; &gt; hmac.txt# 获取摘要值# openssl dgst -sha1 hmac.txt -out hmac-dgst.txt# 获取mac值，mykey为指定密钥openssl dgst -sha1 -hmac &quot;mykey&quot; hmac.txt AE加密模式 结合对称加密算法（提供机密性）和MAC算法（提供防篡改能力，保证消息完整性）的模式叫做AE（Authenticated Encryption）加密模式，主要有以下3种： E&amp;M（Encrypt and MAC） 对消息分别进行加密运算和MAC运算 graph LR plain[明文]-->encode[加密] key[密钥]-->encode[加密] encode[加密]-->cipher[密文] plain[明文]-->mac[MAC算法] key[密钥]-->mac[MAC算法] mac[MAC算法]-->macv[MAC值] MtE（MAC then Encrypt） 先对消息进行MAC运算，然后将消息和MAC值一起进行加密；在https中，一般采用这种方式 graph LR plain[明文]-->mac[MAC算法] key[密钥]-->mac[MAC算法] mac[MAC算法]-->macv[MAC值] plain[明文]-->encode[加密] macv[MAC值]-->encode[加密] key[密钥]-->encode[加密] encode[加密]-->cipher[密文] EtM（Encrypt then MAC） 先对消息进行加密得到密文，然后对密文计算MAC值，最后将密文和MAC值组合在一起发出 graph LR plain[明文]-->encode[加密] key[密钥]-->encode[加密] encode[加密]-->cipher[密文] cipher[密文]-->mac[MAC算法] key[密钥]-->mac[MAC算法] mac[MAC算法]-->macv[MAC值] AEAD加密模式 AE模式需要使用者单独处理加密运算和MAC运算，而AEAD加密模式在底层组合了加密算法和MAC算法。 AEAD加密模式主要有以下3种形式： CCM模式 CCM(Counter with CBC-MAC)，使用CBC-MAC+AES算法的CTR模式，采用MAC-then-Encrypt GCM模式 GCM(Galois/Counter Mode)，使用GHASH算法(一种MAC运算)+AES算法的CTR模式 ChaCha20-Poly1305 ChaCha20-Poly1305是谷歌发明的，使用Poly1305算法(一种MAC运算)+ChaCha20流密码 2.7密钥密钥最重要的属性是密钥的长度 特点 足够长度，达到一定长度才能保证算法安全性 不可预测性，即保证内容一定程度的复杂性，不能是简单的数字、字母组合 生成密钥 基于伪随机生成器生成密钥 基于口令的加密算法(Password based Encryption, PBE)产生密钥 密钥的作用 名称 作用 说明 对称加密算法密钥 加解密 密钥不能泄露 公开密钥算法密钥 加解密 公钥可以公开，私钥不能泄露 MAC算法密钥 消息验证 密钥不能泄露 数字签名算法密钥 身份验证 公钥可以公开，私钥不能泄露 会话密钥 加解密 密钥不能泄露，该密钥一般配合对称加密算法进行加解密 基于口令的密钥 权限校验、加解密 口令不能泄露 口令和PBE算法 口令可以认为是一种密钥；但口令更容易记忆 口令可以用于身份验证，如使用者使用摘要函数处理口令后存储到数据库 口令因容易记忆，很容易遭到暴力攻击，如字典攻击 密码衍生算法(Key Derivation Function，KDF) 通过某些值生成任意长度的一个或多个密钥 常见的KDF算法有：PBKDF2、bcrypt、scrypt等 PBE可以认为是KDF算法的一种具体应用 PBKDF2算法 DK=PBKDF2(PRF, Password, Salt, c, dkLen) PRF，一种摘要算法 Password，口令 Salt，盐值，一个随机数；通过salt避免字典攻击 c，迭代次数，减缓攻击者的破解速度 dkLen，最后输出的密钥长度 密钥存储和传输 静态密钥，需要存储的密钥，一般硬编码在代码中或以口头、邮件的方式传输密钥 动态密钥，每次连接的密钥不一样，也称会话密钥 2.8 密钥协商算法密钥协商算法可以解决密钥分配、存储、传输问题 密钥协商算法，一般有RSA密钥协商算法、DH算法 RSA密钥协商算法 sequenceDiagram participant C as 客户端 participant S as 服务端 note right of S: 优点：每次连接的密钥不同，且不需要存储，做到了“动态” note right of S: 缺点：没有做到“协商”，完全由客户端决定,若客户端生成的密钥过于简单，会遭到暴力破解；不能提供前向安全性 autonumber C->>S: 连接 S-->>C: 返回公钥 C->>S: 生成会话密钥(随机数)，公钥加密 S-->>S: 用私钥解密 DH密钥协商算法 DH算法，一个公开密钥算法，实现的是真正意义上的双方协商密钥算法，即通信双方的任意一方无法独立计算出密钥 参数文件 首先需生成一个参数文件，由双方中其中的一方生成，一般有服务器端生成，参数在协商密钥之前必须发给对方。 通过参数，双方各自生成一个DH密钥对。 参数文件包含2个参数：p、g。 p：很大的质数，建议长度在1024bit以上，决定了DH算法的安全程度 g：一个生成器，值很小，可以是2或者5 DH算法过程 sequenceDiagram participant C as 客户端 participant S as 服务端 note right of S: yc = (g^a) mod p，ys = (g^b) mod p客户端计算Z = (ys^a) mod p客户端计算Z = (yc^b) mod pZ就是会话密钥 autonumber C->>S: 请求DH参数 S-->>S: 生成参数p、g，生成DH私钥b、公钥ys S-->>C: 发送p、g、ys C->>C: 生成DH私钥a、公钥yc，根据ys、a计算Z C->>S: 发送yc S-->>S: 根据yc、b计算Z DH算法分类 分为静态DH算法、临时DH算法 静态DH算法(DH算法) p、g参数，服务器端公钥ys永远固定；一旦服务器端私钥泄露，就不能提供前向安全性；好处在于避免初始化连接时频繁生成参数p、g（消耗cpu） 临时DH算法(EDH算法) 每次初始化连接，都会重新生成参数、密钥对；但更安全，私钥泄露也仅仅影响本次连接，且协商出密钥后，双方私钥可以丢弃 DH算法实践 12345678910111213141516171819202122# 通信双方的任意一方生成DH的参数文件，可以对外公开openssl genpkey -genparam -algorithm DH -out edh.pem# 查看参数文件openssl pkeyparam -in edh.pem -text# 发送方A基于参数文件生成密钥对文件openssl genpkey -paramfile edh.pem -out akey.pem# 查看密钥对文件openssl pkey -in akey.pem -text -noout# 发送方B基于参数文件生成密钥对文件openssl genpkey -paramfile edh.pem -out bkey.pem# 查看密钥对文件openssl pkey -in bkey.pem -text -noout# 发送方A拆出公钥文件openssl pkey -in akey.pem -pubout -out akey_pub.pem# 发送方B拆出公钥文件openssl pkey -in bkey.pem -pubout -out bkey_pub.pem# 发送方A收到B的公钥，将协商的密钥保存openssl pkeyutl -derive -inkey akey.pem -peerkey bkey_pub.pem -out data_a.txt# 发送方B收到A的公钥，将协商的密钥保存openssl pkeyutl -derive -inkey bkey.pem -peerkey akey_pub.pem -out data_b.txt# 查看验证协商的密钥文件内容是否一致diff data_a.txt data_b.txt 2.9 椭圆曲线密码学2.10 数字签名","categories":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://yclii.github.io/workbook/categories/HTTPS/"}],"tags":[{"name":"SSL,TLS,OpenSSL","slug":"SSL-TLS-OpenSSL","permalink":"https://yclii.github.io/workbook/tags/SSL-TLS-OpenSSL/"}]},{"title":"Docker技术入门与实践学习笔记","slug":"Docker技术入门与实践学习笔记","date":"2021-06-23T15:25:08.000Z","updated":"2022-01-13T02:23:11.877Z","comments":true,"path":"2021/06/23/Docker技术入门与实践学习笔记/","link":"","permalink":"https://yclii.github.io/workbook/2021/06/23/Docker%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"技术介绍Docker 是一个基于Go语言实现的开源应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux 或 Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 历史 Docker 是 PaaS 提供商 dotCloud 开源的一个基于 LXC 的高级容器引擎，源代码托管在 Github 上, 基于go语言并遵从Apache2.0协议开源。 诞生于2013年年初，发起者是dotCloud公司。2013年年底，dotCloud公司直接改名为Docker Inc，专注于Docker相关技术和产品的开发，目前已成为全球最大的Docker容器服务提供商。官网：docker.com 2014年，Docker镜像下载数达到了一百万次，2015年，突破十亿次，2017年，突破百亿次。 目前主流的操作系统，包括Linux各大发行版、macOS、Windows等都已经支持Docker。 优势 应用直接运行在底层操作系统上，无法保证同一份应用在不同环境行为一致。Docker通过容器来打包应用，解耦了应用和运行平台。 Docker可以快速创建和删除容器，实现快速的交付和部署。 Docker是内核级的虚拟化，不需要额外的虚拟化管理程序（Virtual Machine Manager，VMM，以及Hypervisor）的支持，可以更高效的利用资源。 Docker与虚拟化 在计算机技术中，虚拟化是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以用比原来的组态更好的方式来应用这些资源。 虚拟化的核心是对资源的抽象，一般为了在同一个主机上同时运行多个系统或应用，从而提高系统资源的利用率，并且能降低成本、方便管理和容错容灾。 虚拟化技术分类： 基于硬件 真正基于硬件的不多，少数如网卡中的单根多IO虚拟化技术 基于软件 2.1 应用虚拟化 一般指的是一些模拟设备或诸如Wine的软件 2.2 平台虚拟化 完全虚拟化 虚拟机模拟完整的底层硬件环境。如IBM p和z系列的虚拟化、VMware Workstation、VirtualBox、QEMU等 硬件辅助虚拟化 利用硬件（主要是CPU）辅助支持（目前X86体系结构上可用的硬件辅助虚拟化技术包括Intel-VT和AMD-V）处理敏感指令来实现完全虚拟化的功能。如VMware Workstation、Xen、KVM等 部分虚拟化 只针对部分硬件资源进行虚拟化 超虚拟化 部分硬件接口以软件的形式提供给客户机操作系统，客户操作系统需要进行修改。如早期的Xen 操作系统级虚拟化 内核通过创建多个虚拟的操作系统实例（内核和库）来隔离不同的进程。容器相关的技术就在这个范畴。 与传统虚拟机技术的比较： 特性 容器 虚拟机 启动速度 秒级 分钟级 性能 接近原生 较弱 内存代价 很小 较多 硬盘使用 一般为MB 一般为GB 运行密度 单机支持上千个容器 一般几十个 隔离性 安全隔离 完全隔离 迁移性 优秀 一般 传统方式是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统层。 Docker容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，因此更加轻量。 Docker引擎 Docker引擎是运行和编排容器的基础设施工具，类比于vmware的ESXi（运行虚拟机的核心管理程序） 很多产品都集成了Docker引擎 安装 Docker引擎 访问https://www.docker.com/get-docker，查看获取Docker的方式，以及Docker支持的操作系统 目前Docker支持以下服务： Docker引擎，提供容器集群编排和管理 DockerHub，官方的云托管服务，可提供公有或私有的镜像仓库 DockerCloud，官方提供的容器云服务 123456789101112131415# 查看操作系统内核uname -a# 添加软件源yum-config-manager --add-repo https://download.docker.com/linux/fedora/docker-ce.repoyum install -y docker-cedocker version# 自启动systemctl enable docker.service# 启动systemctl start docker.service# 或者通过官方脚本安装# 脚本会自动检测系统信息并进行相应配置curl -fsSL https://get.docker.com/|sh# 或者 wget -qO https://get.docker.com/|sh 升级Docker引擎 1234567891011# 1. 停止docker后台服务systemctl stop docker.service# 2. 移除旧版本# 在之前的版本中，Docker 引擎的包名可能有多个。这条命令能够确保已经安装的Docker包全部被删除。yum remove docker docker-engine docker-ce docker.io -y# 3. 安装新版本wget -qO https://get.docker.com/ | sh# 4. 设置开机自启动systemctl enable docker.service# 查看自启动状态systemctl is-enabled docker.service 配置信息 123456789101112131415161718192021222324# 1. /etc/docker/daemon.json# 没有就创建# 添加默认仓库镜像vi /etc/docker/daemon.json# 添加以下内容&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;]&#125;# 2. /etc/default/docker# 没有就创建# 添加默认仓库镜像（不能与daemon.json中定义相同的属性，如不能同时添加仓库镜像）vi /etc/docker/daemon.json# 添加以下内容DOCKER_OPTS=&quot;--registry-mirror=https://registry.docker-cn.com&quot;# 对应修改文件/usr/lib/systemd/system/docker.service# 在[Service]节点内，添加或修改以下内容# 减号-表示忽略错误EnvironmentFile=-/etc/default/dockerExecStart=/usr/bin/dockerd -H fd:// $DOCKER_OPTS --containerd=/run/containerd/containerd.sock# 刷新后台进程以及重启dockersudo systemctl daemon-reloadsudo systemctl restart docker# 查询后台进程状态sudo systemctl status docker 开放容器计划（OCI） 开发容器计划(Open Container Initiative)，旨在对容器基础架构中的基础组件（如镜像格式与容器运行时）进行标准化的管理委员会 CoreOS 的公司不喜欢 Docker 的某些行事方式。因此它就创建了一个新的开源标准，称作“appc”，该标准涉及诸如镜像格式和容器运行时等方面。 为了标准化Docker公司与CoreOS公司发布的两种不同的容器规则，成立了OCI委员会。 OCI 在 Linux 基金会的支持下运作，Docker 公司和 CoreOS 公司都是主要贡献者。 容器生态 Docker 公司的一个核心哲学通常被称为“含电池，但可拆卸”（Batteries included but removable） 许多 Docker 内置的组件都可以替换为第三方的组件 镜像Docker 镜像由多个层组成，每层叠加后，从外部看就如一个独立的对象。镜像内部是一个精简的操作系统，同时包含应用运行所必需的文件和依赖包。镜像类比于VM模板或类（Class）文件。 镜像通常比较小，构建镜像时通常会裁剪掉不必要的部分，镜像不包含容器共享的主机内核，仅包含必要的操作系统（操作系统文件和文件系统对象）。 获取镜像 1234567# 语法格式# registry 远程仓库注册服务器，默认为DockerHub注册服务器地址# repository 仓库名称# tag 仓库标签，默认为lastest，表示最新，会动态变化，生产环境不要使用docker [image] pull [registry/]repository[:tag] # digest，摘要值。根据摘要值可以获取精确的仓库版本docker [image] pull [registry/]repository[@digest] Linux 主机本地镜像仓库通常位于 /var/lib/docker/&lt;storage-driver&gt;，Windows主机则是 C:\\ProgramData\\docker\\windowsfilter。 查看镜像 12# 查看本地镜像docker images # 或 docker image ls 支持的选项： -a,–all=true|false: 列出所有（包括临时文件）镜像文件，默认为false 1docker images -a # 或者 docker image ls -a –digests=true|false: 列出镜像摘要值，默认为false 1docker images --digests=true -f,–filter=[]: 过滤镜像 Docker 目前支持如下的过滤器。 dangling：可以指定 true 或者 false，仅返回悬虚镜像（没有标签的镜像）（true），或者非悬虚镜像（false）。 before：需要镜像名称或者 ID 作为参数，返回在之前被创建的全部镜像。 since：与 before 类似，不过返回的是指定镜像之后创建的全部镜像。 label：根据标注（label）的名称或者值，对镜像进行过滤。docker image ls命令输出中不显示标注内容。 其他过滤方式可以通过reference完成过滤 123456# 输出悬虚镜像docker images --filter danling=true # 或者docker images --filter=danling=true# 输出本地在alpine镜像之前的所有镜像docker images --filter=before=alpine# 输出所有标签为lastest的镜像docker images --filter=reference=&quot;*:lastest&quot; –format=”TEMPLATE”: 控制输出格式，如.ID表示ID信息，.Repository表示仓库信息 1234# 只输出镜像大小属性docker images --format=&quot;&#123;&#123;.Size&#125;&#125;&quot;# 输出镜像的仓库、标签、大小属性docker images --format=&quot;&#123;&#123;.Repository&#125;&#125;:&#123;&#123;.Tag&#125;&#125;:&#123;&#123;Size&#125;&#125;&quot; –no-trunc=true|false: 对输出结果中太长部分是否进行截断，如镜像ID。默认为true 1docker images --no-trunc=false -q,–quiet=true|false: 仅输出ID，默认为false 1docker images -q 更多信息 man docker-images查看 1234# 查看镜像内部信息，返回的是json格式信息，包括镜像存储分层信息等docker image inspect alpine# 查看镜像构建历史过程信息docker history alpine 搜寻镜像 12345678# 搜索镜像docker search alpine# 搜索官方镜像docker search alpine --filter=is-official=true# 搜索支持自动创建功能的镜像docker search alpine --filter=is-automated=true# 搜索结果限制，默认限制为25条docker search alpine --limit=100 删除镜像 1234567891011# IMAGE为ID或标签docker rmi IMAGE[IMAGE...] # 或者 docker image rm IMAGE[IMAGE...]# 支持的选项有-f,-force:强制删除镜像，即使有容器依赖-no-prune:不清理未带标签的镜像# 实例# 若镜像存在多个标签，则只会删除对应标签，不会删除镜像文件；若只剩下一个标签，若继续删除，则会删除镜像文件docker rmi alpine:lastest# 删除ID对应镜像，则会先删除该镜像的所有标签，然后删除该镜像文件docker rmi 543254ab42 清理镜像 使用Docker一段时间后，系统可能会遗留一些临时的镜像文件或没有被使用的镜像。可以通过docker image prune命令进行清理 1234567docker image prune# 支持的选项有-a,-all: 删除所有无用的镜像-filter：清理符合给定过滤器的镜像-f,-force:强制删除，且不进行提示确认# 实例docker image prune -f 创建镜像 创建镜像的方法有3种：基于已有镜像的容器创建、基于模板导入、基于Dockerfile创建 基于已有镜像的容器创建 123456789101112docker [container] commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]# OPTIONS主要包括：-a,--author=&quot;&quot;:作者信息-c,--change=[]:提交的时候执行的Dockerfile指令-m,--message=&quot;&quot;:提交信息-p,--pause=true|false:提交时是否暂停容器# CONTAINER,容器ID或名称# REPOSITORY:TAG, 生成的镜像标签# 实例docker commit -m &quot;create a new image&quot; -a &quot;Docker lee&quot; a925cb40 test:1.0# 查看创建的镜像docker images --filter=reference=&quot;*test:1.0&quot; 基于模板导入 1234567docker [image] import [OPTIONS] file|URL|-[REPOSITORY[:TAG]]# 实例# 下载模板wget -qO http://openvz.org/Download/templates/precreated/fedora-22-x86_64.tar.gzcat fedora-22-x86_64.tar.gz|docker import -myfedora:1.0# 查看创建的镜像docker images --filter=reference=&quot;*myfedora:1.0&quot; 基于Dockerfile创建 Dockerfile是一个文本格式的配置文件，用户可以快速自定义镜像。 123456FROM debian:strech-slimLABEL version=&quot;1.0&quot; maintainer=&quot;szhang&lt;szhang@github.com&gt;&quot;RUN apt-get update &amp;&amp; \\ apt-get install -y python3 &amp;&amp; \\ apt-get clean &amp;&amp; \\ rm -rf /var/lib/apt/lists/* 12# 基于Dockerfile创建镜像docker [image] build -t python:3 . 导出和导入镜像 1234567891011# 导出镜像docker [image] save [OPTIONS]# 支持的选项有：-o,-output:导出文件路径# 实例docker save -o alpine_1.0.tar alpine:1.0# 导入镜像docker load -i alpine_1.0.tar# 或者docker load &lt; alpine_1.0.tar 上传镜像 123456docker [image] push REPOSITORY[:TAG]|[REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]# 打标签docker tag test:latest user/test:latest# 上传# 第一次上传时，会提示输入登录信息docker push user/test:latest 容器Docker 容器类似于一个轻量级沙箱，用于隔离和运行应用。 仓库Docker 集中存放镜像文件的地方。默认的仓库是 Docker Hub，地址：https://hub.docker.com 登录Docker Hub 12# 命令登录（或注册）成功后，会生成文件~/.docker/config.json，保存用户认证信息docker login 是否官方镜像 镜像属性 is-official，若为true，表示镜像由Docker公司创建、验证、支持、文档提供；否则，表示镜像由Docker用户创建维护的 自动创建 自动创建（Automated Builds）是Docker Hub提供的自动化服务，可以实现跟随项目代码的变更而自动重新构建镜像。 支持GitHub、BitBucket，一旦项目发生新的提交，就自动执行创建镜像。 创建步骤如下： 登录Docker Hub，以及目标网站GitHub 在目标网站中允许Docker Hub访问服务 在Docker Hub中配置一个“自动创建”类型的项目 选取目标网站中的项目分支（包含Dockerfile） 指定Dockerfile的位置，并提交创建 之后就可以在Docker Hub的“自动创建”页面中跟踪每次创建的状态。 国内的镜像仓库地址 Docker中国区官方镜像 https://registry.docker-cn.com 网易 http://hub-mirror.c.163.com 中国科技大学 https://docker.mirrors.ustc.edu.cn 阿里云容器服务 https://cr.console.aliyun.com/ 时速云 https://hub.tenxcloud.com 123456# 添加镜像仓库vi /etc/docker/daemon.json# 添加或修改属性registry-mirrors，按序检索&#123; &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;,&quot;https://cr.console.aliyun.com&quot;,&quot;http://hub-mirror.c.163.com&quot;,&quot;http://hub-mirror.c.163.com&quot;,&quot;https://hub.tenxcloud.com&quot;]&#125; 存储驱动Dockerfile数据管理端口映射与容器互联为镜像添加SSH服务文档说明文档内容来源其它文档的学习总结，引用的文档包括： 《l中国编程网-Docker篇》 http://c.biancheng.net/view/3130.html 《Docker技术入门与实践》作者：杨保华","categories":[{"name":"devOpts","slug":"devOpts","permalink":"https://yclii.github.io/workbook/categories/devOpts/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://yclii.github.io/workbook/tags/docker/"}]},{"title":"mermaid使用手册","slug":"mermaid使用手册","date":"2021-05-21T19:44:56.000Z","updated":"2022-01-01T05:39:24.847Z","comments":true,"path":"2021/05/21/mermaid使用手册/","link":"","permalink":"https://yclii.github.io/workbook/2021/05/21/mermaid%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","excerpt":"","text":"概述 It is a Javascript based diagramming and charting tool that renders Markdown-inspired text definitions to create and modify diagrams dynamically. 它是一个基于Javascript的图表和坐标图工具，可以呈现基于Markdown的文本定义来动态地创建和修改图表。 安装 官网地址：https://mermaid-js.github.io/mermaid/#/ 源码安装（在线编辑） git clone https://github.com/mermaid-js/mermaid-live-editor.git 进入目录后，npm install，然后启动 npm run dev。 发布版安装 npm init npm install -S mermaid 新建一文本，写入mermaid组件语句，如： 123456789101112131415ganttdateFormat YYYY-MM-DDtitle 项目交付计划 section 里程碑 0.1 数据库设计:active,p1,2016-08-15,3d详细设计:p2,after p1,2d section 里程碑 0.2后端开发:p3,2016-08-22,20d前端开发:p4,2016-08-22,15d section 里程碑 0.3功能测试:p6,after p3,5d上线:p7,after p6,2d 命名为demo.gantt，然后使用一下命令： 1mermaid demo.gantt -w 1920 -s -p -o images 就会在images目录下生成两个文件，一个svg文件、一个png图片文件。 1234-s --svg 输出 SVG 替代 PNG（试验性的功能）。-p --png 如果选择保存 SVG，那么加上这个选项可以同时保存 PNG。-o --outputDir 保存文件的目录（如果不存在会自动创建），默认 `cwd`。-w --width 生成的图片宽度 typora插件（安装typora即可） typora工具默认集成了mermaid，使用&lt;pre class=&quot;mermaid&quot;&gt;即可开启mermaid功能。刻意输入不合法的语法，即可显示当前mermaid版本。 ==说明：本文档所有示例采用第三种，typora插件== 图表类型流程图（FlowChart） All Flowcharts are composed of nodes, the geometric shapes and edges, the arrows or lines. The mermaid code defines the way that these nodes and edges are made and interact. 流程图就是一些节点、几何图形、边界、箭头和线条的组合。 graph语句 流程图是从graph语句开始，graph语句表示流程图的方向，默认是从top到bottom（TD或TB）。可能的方向包括： 方向 说明 TB top to bottom TD top-down，等同于TB BT bottom to top RL right to left LR left to right 默认节点 1234567891011graph TB ID&lt;/pre&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph TB ID&lt;/pre&gt;```markdowngraph TB ID[hello] graph TB ID[hello] 12graph TB ID(hello) graph TB ID(hello) 12graph TB ID([hello]) graph TB ID([hello]) 12graph TB ID((hello)) graph TB ID((hello)) 12graph TB ID[[hello]] graph TB ID[[hello]] 12graph TB ID[(hello)] graph TB ID[(hello)] 12graph TB ID&gt;hello] graph TB ID>hello] 12graph TB ID&#123;hello&#125; graph TB ID{hello} 12graph TB ID&#123;&#123;hello&#125;&#125; graph TB ID 12graph TB ID[/hello/] graph TB ID[/hello/] 12graph TB ID[\\hello/] graph TB ID[\\hello/] 12graph TB ID[/hello\\] graph TB ID[/hello\\] 连线 12graph LR A--&gt;B graph LR A-->B 12graph LR A--hello--&gt;B graph LR A--hello-->B 12graph LR A--&gt;|hello|B graph LR A-->|hello|B 12graph LR A---B graph LR A---B 12graph LR A--hello---B graph LR A--hello---B 12graph LR A---|hello|B graph LR A---|hello|B 12graph LR A-.-&gt;B graph LR A-.->B 12graph LR A-.hello.-&gt;B graph LR A-.hello.->B 12graph LR A-.-&gt;|hello|B graph LR A-.->|hello|B 12graph LR A-.-B graph LR A-.-B 12graph LR A-.hello.-B graph LR A-.hello.-B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A==&gt;B graph LR A==>B 12graph LR A==hello==&gt;B graph LR A==hello==>B 12graph LR A==&gt;|hello|B graph LR A==>|hello|B 12graph LR A--&gt;|hello|B--&gt;|hello|C graph LR A-->|hello|B-->|hello|C 12graph LR A--&gt;|hello|B &amp; C--&gt;D graph LR A-->|hello|B & C-->D 12graph A &amp; B --&gt; C &amp; D graph A & B --> C & D 123456graph A[开始]--&gt;B&#123;Yes or No?&#125; B--&gt;|Yes|C[OK] C--&gt;D[Rethink] D--&gt;B B--&gt;|No|E[结束] graph LR A[开始]-->B{Yes or No?} B-->|Yes|C[OK] C-->D[Rethink] D-->B B-->|No|E[结束] 含有特殊字符的字符串需要用双引号 12graph A[&quot;hello(world)&quot;] graph A[\"hello(world)\"] Subgraphs 语法格式： 123subgraph title graph definitionend 12345678910graph TB subgraph one A1--&gt;A2 end subgraph two B1--&gt;B2 end subgraph three C1-&gt;C2 end graph TB A1-->C2 subgraph three C1-->C2 end subgraph two B1-->B2 end subgraph one A1-->A2 end 样式 1234graph LR id1(Start)--&gt;id2(Stop) style id1 fill:#f9f,stroke:#333,stroke-width:4px style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5 graph LR id1(Start)-->id2(Stop) style id1 fill:#f9f,stroke:#333,stroke-width:4px style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5 时序图（Sequence） A Sequence diagram is an interaction diagram that shows how processes operate with one another and in what order. 时序图就是用来展示进程间按照某种排序进行交互的图形 12345sequenceDiagram autonumber 张三-&gt;&gt;李四: Hello 李四, how are you? 李四--&gt;&gt;张三: Great! 张三--&gt;&gt;李四: See you later! sequenceDiagram autonumber 张三->>李四: Hello 李四, how are you? 李四-->>张三: Great! 张三-->>李四: See you later! 123456sequenceDiagram participant A as 张三 participant B as 李四 A-&gt;&gt;B: Hello 李四, how are you? B-xA: Great! A--xB: See you later! sequenceDiagram participant A as 张三 participant B as 李四 A->>B: Hello 李四, how are you? B-xA: Great! A--xB: See you later! 12345678sequenceDiagram participant A as 张三 participant B as 李四 A-&gt;&gt;B: Hello 李四, how are you? activate B B-xA: Great! deactivate B A--xB: See you later! sequenceDiagram participant A as 张三 participant B as 李四 A->>B: Hello 李四, how are you? activate B B-xA: Great! deactivate B A--xB: See you later! 123456sequenceDiagram participant A as 张三 participant B as 李四 A-&gt;&gt;+B: Hello 李四, how are you? B-x-A: Great! A--xB: See you later! sequenceDiagram participant A as 张三 participant B as 李四 A->>+B: Hello 李四, how are you? B-x-A: Great! A--xB: See you later! 1234567sequenceDiagram participant A as 张三 participant B as 李四 note right of B: 我是李四 A-&gt;&gt;B: Hello 李四, how are you? B--&gt;&gt;A: Great! A--&gt;&gt;B: See you later! note right of|left of|over sequenceDiagram participant A as 张三 participant B as 李四 note right of B: 我是李四 A->>B: Hello 李四, how are you? B-->>A: Great! A-->>B: See you later! 12345678sequenceDiagram autonumber participant A as 张三 participant B as 李四 note over A,B: 张三，李四 A-&gt;&gt;B: Hello 李四, how are you? B--&gt;&gt;A: Great! A--&gt;&gt;B: See you later! sequenceDiagram autonumber participant A as 张三 participant B as 李四 note over A,B: 张三，李四 A->>B: Hello 李四, how are you? B-->>A: Great! A-->>B: See you later! 1234567sequenceDiagram participant A as 张三 participant B as 李四 A-&gt;&gt;B: Hello 李四, how are you? loop 每个一分钟 B--&gt;&gt;A: Great! end sequenceDiagram participant A as 张三 participant B as 李四 A->>B: Hello 李四, how are you? loop 每个一分钟 B-->>A: Great! end 123456789101112sequenceDiagram participant A as 张三 participant B as 李四 A-&gt;&gt;B: Hello 李四, how are you? alt 感冒了 B--&gt;&gt;A: 感冒了:( else 很好 B--&gt;&gt;A: 吃嘛嘛香:) end opt 额外的响应 B--&gt;&gt;A: 谢谢关心！ end sequenceDiagram participant A as 张三 participant B as 李四 A->>B: Hello 李四, how are you? alt 感冒了 B-->>A: 感冒了:( else 很好 B-->>A: 吃嘛嘛香:) end opt 额外的响应 B-->>A: 谢谢关心！ end 12graph LR A-.-|hello|B sequenceDiagram participant A as 张三 participant B as 李四 participant C as 王五 par 张三 to 李四 A-->>B: 最近咋样？ and 张三 to 王五 A-->>C: 最近咋样？ end 12345678910111213141516sequenceDiagram participant A as 张三 participant B as 李四 rect rgba(153,50,204,.9) A-&gt;&gt;B: Hello 李四, how are you? alt 感冒了 B--&gt;&gt;A: 感冒了:( else 很好 B--&gt;&gt;A: 吃嘛嘛香:) end end rect rgba(255,0,255) opt 额外的响应 B--&gt;&gt;A: 谢谢关心！ end end sequenceDiagram participant A as 张三 participant B as 李四 rect rgba(153,50,204,.9) A->>B: Hello 李四, how are you? alt 感冒了 B-->>A: 感冒了:( else 很好 B-->>A: 吃嘛嘛香:) end end rect rgba(255,0,255) opt 额外的响应 B-->>A: 谢谢关心！ end end 类图（Class） The class diagram is the main building block of object-oriented modeling. It is used for general conceptual modeling of the structure of the application, and for detailed modeling translating the models into programming code. Class diagrams can also be used for data modeling. The classes in a class diagram represent both the main elements, interactions in the application, and the classes to be programmed. 类图是面向对象建模的主要构件。它用于应用程序结构的一般概念建模，以及将模型转换为编程代码的详细建模。类图也可以用于数据建模。类图中的类表示主要元素、应用程序中的交互以及要编程的类。 12345678910111213141516171819202122232425262728293031classDiagram Animal &lt;|-- Duck Animal &lt;|-- Fish Animal &lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck&#123; +String beakColor +swim() +quack() &#125; class Fish&#123; -int sizeInFeet -canEat() &#125; class Zebra&#123; +bool is_wild +run() &#125; %% Generic Types class Square~Shape~&#123; int id List~Integer~ position setPoints(List~Integer~ points) getPoints() List~Integer~ &#125; Square:-List~String~ message Square:+setMessage(List~String~ message) Square:+getMessage() List~String~ classDiagram Animal ClassF:关联 ClassG ..> ClassH:依赖 ClassG1 .. ClassH1:双向依赖 ClassI ..* ClassJ:组合 ClassK --o ClassL:聚合 状态图（State） A state diagram is a type of diagram used in computer science and related fields to describe the behavior of systems. State diagrams require that the system described is composed of a finite number of states; sometimes, this is indeed the case, while at other times this is a reasonable abstraction. 状态图是计算机科学和相关领域中用来描述系统行为的一种图。状态图要求所描述的系统由有限个状态组成；有时，情况确实如此，而有时这是一种合理的抽象。 12345678stateDiagram-v2 [*] --&gt; Still Still --&gt; [*]:transition Still --&gt; Moving Moving --&gt; Still Moving --&gt; Crash Crash --&gt; [*] stateDiagram-v2 [*] --> Still Still --> [*]:transition Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] 123stateDiagram-v2 state &quot;hello&quot; as s1 s2:hello stateDiagram-v2 state \"hello\" as s1 s2:hello 12graph LR A-.-|hello|B graph LR A-.-|hello|B 123456789101112131415stateDiagram-v2 [*] --&gt; First state First &#123; [*] --&gt; Second state Second &#123; [*] --&gt; second second --&gt; Third state Third &#123; [*] --&gt; third third --&gt; [*] &#125; &#125; &#125; stateDiagram-v2 [*] --> First state First { [*] --> Second state Second { [*] --> second second --> Third state Third { [*] --> third third --> [*] } } } 1234567891011121314151617stateDiagram-v2 [*] --&gt; First First --&gt; Second First --&gt; Third state First &#123; [*] --&gt; fir fir --&gt; [*] &#125; state Second &#123; [*] --&gt; sec sec --&gt; [*] &#125; state Third &#123; [*] --&gt; thi thi --&gt; [*] &#125; stateDiagram-v2 [*] --> First First --> Second First --> Third state First { [*] --> fir fir --> [*] } state Second { [*] --> sec sec --> [*] } state Third { [*] --> thi thi --> [*] } 1234567891011stateDiagram-v2 state fork_state &lt;&lt;fork&gt;&gt; [*] --&gt; fork_state fork_state --&gt; State2 fork_state --&gt; State3 state join_state &lt;&lt;join&gt;&gt; State2 --&gt; join_state State3 --&gt; join_state join_state --&gt; State4 State4 --&gt; [*] stateDiagram-v2 state fork_state [*] --> fork_state fork_state --> State2 fork_state --> State3 state join_state State2 --> join_state State3 --> join_state join_state --> State4 State4 --> [*] 12345678stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --&gt; State2 note left of State2 : This is the note to the left. stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --> State2 note left of State2 : This is the note to the left. 12345678910111213141516stateDiagram-v2 [*] --&gt; Active state Active &#123; [*] --&gt; NumLockOff NumLockOff --&gt; NumLockOn : EvNumLockPressed NumLockOn --&gt; NumLockOff : EvNumLockPressed -- [*] --&gt; CapsLockOff CapsLockOff --&gt; CapsLockOn : EvCapsLockPressed CapsLockOn --&gt; CapsLockOff : EvCapsLockPressed -- [*] --&gt; ScrollLockOff ScrollLockOff --&gt; ScrollLockOn : EvScrollLockPressed ScrollLockOn --&gt; ScrollLockOff : EvScrollLockPressed &#125; stateDiagram-v2 [*] --> Active state Active { [*] --> NumLockOff NumLockOff --> NumLockOn : EvNumLockPressed NumLockOn --> NumLockOff : EvNumLockPressed -- [*] --> CapsLockOff CapsLockOff --> CapsLockOn : EvCapsLockPressed CapsLockOn --> CapsLockOff : EvCapsLockPressed -- [*] --> ScrollLockOff ScrollLockOff --> ScrollLockOn : EvScrollLockPressed ScrollLockOn --> ScrollLockOff : EvScrollLockPressed } 实体关系图（Entity Relationship） An entity–relationship model (or ER model) describes interrelated things of interest in a specific domain of knowledge. A basic ER model is composed of entity types (which classify the things of interest) and specifies relationships that can exist between entities (instances of those entity types). 实体-关系模型（或ER模型）描述特定知识领域中相关的事物。基本ER模型由实体类型（对感兴趣的事物进行分类）组成，并指定实体之间可能存在的关系（这些实体类型的实例）。 1234erDiagram CUSTOMER ||--o&#123; ORDER : places ORDER ||--|&#123; LINE-ITEM : contains CUSTOMER &#125;|..|&#123; DELIVERY-ADDRESS : uses erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses Relationship Relationship Description o| Zero or one || Exactly one o{ Zero or more |{ One or more 用户体验图（User Journey） User journeys describe at a high level of detail exactly what steps different users take to complete a specific task within a system, application or website. This technique shows the current (as-is) user workflow, and reveals areas of improvement for the to-be workflow. 用户旅程详细地描述了不同用户在系统、应用程序或网站中完成特定任务所采取的步骤。这项技术显示了当前（原样）用户工作流，并揭示了未来工作流的改进领域。 123456789journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me 甘特图（Gantt） A Gantt chart is a type of bar chart, first developed by Karol Adamiecki in 1896, and independently by Henry Gantt in the 1910s, that illustrates a project schedule and the amount of time it would take for any one project to finish. Gantt charts illustrate number of days between the start and finish dates of the terminal elements and summary elements of a project. 甘特图是一种条形图，由Karol Adamiecki于1896年首次开发，由Henry Gantt于1910年独立开发，用于说明项目进度和任何一个项目完成所需的时间。甘特图显示了项目的终端元素和摘要元素的开始日期和完成日期之间的天数。 1234567891011121314151617181920212223242526272829gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid excludes weekends %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week (&quot;sunday&quot;) or &quot;weekends&quot;, but not the word &quot;weekdays&quot;.) section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid excludes weekends %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week (\"sunday\") or \"weekends\", but not the word \"weekdays\".) section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h","categories":[{"name":"tool","slug":"tool","permalink":"https://yclii.github.io/workbook/categories/tool/"}],"tags":[{"name":"mermaid","slug":"mermaid","permalink":"https://yclii.github.io/workbook/tags/mermaid/"}]},{"title":"git学习笔记","slug":"git学习笔记","date":"2021-05-20T15:16:25.000Z","updated":"2021-10-27T11:13:08.609Z","comments":true,"path":"2021/05/20/git学习笔记/","link":"","permalink":"https://yclii.github.io/workbook/2021/05/20/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"概述开源的分布式版本控制系统 历史","categories":[{"name":"devOpts","slug":"devOpts","permalink":"https://yclii.github.io/workbook/categories/devOpts/"}],"tags":[{"name":"git","slug":"git","permalink":"https://yclii.github.io/workbook/tags/git/"}]},{"title":"AWR报告解析","slug":"AWR报告解析","date":"2021-05-10T23:00:08.000Z","updated":"2021-10-27T11:13:08.609Z","comments":true,"path":"2021/05/10/AWR报告解析/","link":"","permalink":"https://yclii.github.io/workbook/2021/05/10/AWR%E6%8A%A5%E5%91%8A%E8%A7%A3%E6%9E%90/","excerpt":"","text":"概述1997-06: ECMAScript 1First edition. 1998-06: ECMAScript 2","categories":[{"name":"oracle","slug":"oracle","permalink":"https://yclii.github.io/workbook/categories/oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://yclii.github.io/workbook/tags/oracle/"},{"name":"AWR","slug":"AWR","permalink":"https://yclii.github.io/workbook/tags/AWR/"}]},{"title":"vscode开发vue的配置与插件","slug":"vscode开发vue的配置与插件","date":"2021-05-10T02:36:36.000Z","updated":"2021-10-27T11:13:08.611Z","comments":true,"path":"2021/05/09/vscode开发vue的配置与插件/","link":"","permalink":"https://yclii.github.io/workbook/2021/05/09/vscode%E5%BC%80%E5%8F%91vue%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%8F%92%E4%BB%B6/","excerpt":"","text":"概述介绍用vscode开发vue程序的相关配置与辅助插件 配置 vue代码片段模板 ctrl+shift+p，打开命令窗口，输入Snippets，出现下图： 输入vue，选择vue.code-snippets： 会在当前项目根目录中生成.vscode/vue.code-snippets文件，在文件中添加以下内容： 123456789101112131415161718192021222324252627282930313233&quot;vue&quot;: &#123; &quot;prefix&quot;: &quot;vue&quot;, &quot;body&quot;: [ &quot;&lt;!--&quot;, &quot;* @description $1&quot;, &quot;* @fileName $TM_FILENAME&quot;, &quot;* @author ycli&quot;, &quot;* @date $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND&quot;, &quot;!--&gt;&quot;, &quot;&lt;template&gt;&quot;, &quot; &lt;div&gt;$0&lt;/div&gt;&quot;, &quot;&lt;/template&gt;&quot;, &quot;&quot;, &quot;&lt;script&gt;&quot;, &quot;export default &#123;&quot;, &quot; data () &#123;&quot;, &quot; return &#123;&quot;, &quot; &#125;&quot;, &quot; &#125;,&quot;, &quot;&quot;, &quot; components: &#123;&#125;,&quot;, &quot;&quot;, &quot; computed: &#123;&#125;,&quot;, &quot;&quot;, &quot; mounted: &#123;&#125;,&quot;, &quot;&quot;, &quot; methods: &#123;&#125;&quot;, &quot;&#125;&quot;, &quot;&quot;, &quot;&lt;/script&gt;&quot;, ], &quot;description&quot;: &quot;vue初始化页面&quot; &#125; 新建.vue的文件，在文件中输入vue（对应上面配置属性preffix），回车： 插件 vetur 功能：语法高亮 vue 3 snippets 功能：基于最新的 Vue 2 及 Vue 3 的 API 添加了 Code Snippets element ui Snippets 功能：通过快捷代码快速制定element-ui组件代码片段，如输入elt，回车后会自动生成el-table节点","categories":[{"name":"vscode","slug":"vscode","permalink":"https://yclii.github.io/workbook/categories/vscode/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://yclii.github.io/workbook/tags/vscode/"},{"name":"vue","slug":"vue","permalink":"https://yclii.github.io/workbook/tags/vue/"}]},{"title":"maven学习笔记","slug":"maven学习笔记","date":"2021-05-10T01:37:18.000Z","updated":"2021-10-27T11:13:08.610Z","comments":true,"path":"2021/05/09/maven学习笔记/","link":"","permalink":"https://yclii.github.io/workbook/2021/05/09/maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"概述maven是一个项目管理工具，包含了一个项目对象模型（POM，project object model）、一组标准集合（遵循约定优于配置[COC，conversion over configuration]原则，规定了一些规范，如项目目录规范、变量规范、版本规范等）、一个项目声明周期、一个依赖管理，以及运行定义在声明周期阶段（phase）中插件（plugin）的目标（goal）中的逻辑。 安装 准备资源 win7、jdk8、maven3.x、eclipse POM遵循的约定依赖管理生命周期多模块与继承Profile属性和资源过滤套件站点nexusm2eclipse手写插件参考资料 maven权威指南","categories":[{"name":"maven","slug":"maven","permalink":"https://yclii.github.io/workbook/categories/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://yclii.github.io/workbook/tags/maven/"}]},{"title":"vue学习笔记","slug":"vue学习笔记","date":"2021-05-09T22:36:19.000Z","updated":"2021-10-27T11:13:08.611Z","comments":true,"path":"2021/05/09/vue学习笔记/","link":"","permalink":"https://yclii.github.io/workbook/2021/05/09/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"概述MVVM安装 准备资源 win7、node、vue2.x、element-ui Vue实例指令计算属性数组更新表单与v-model组件参考文档 vue中文官网文档 vue.js实战.梁灏 vue.js项目开发实战.张帆","categories":[{"name":"vue","slug":"vue","permalink":"https://yclii.github.io/workbook/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yclii.github.io/workbook/tags/vue/"}]},{"title":"mysql源码安装","slug":"mysql源码安装","date":"2021-05-09T18:30:03.000Z","updated":"2021-10-27T11:13:08.610Z","comments":true,"path":"2021/05/09/mysql源码安装/","link":"","permalink":"https://yclii.github.io/workbook/2021/05/09/mysql%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/","excerpt":"","text":"概述实现mysql的源码安装 安装 准备资源 win7、mysql8 资源下载 https://dev.mysql.com/downloads/mysql/ 配置文件 将压缩包解压到磁盘目录，并在系统环境变量中添加变量Mysql_HOME，并添加%Mysql_HOME%\\bin;到环境变量Path中。 在安装目录下，新建my.ini文件，并添加如下内容： 12345678910111213141516171819202122232425262728293031323334353637383940# 客户端设置 [mysql]default-character-set=utf8mb4 # 服务端设置 [mysqld]# 端口port=3306# 设置mysql的安装目录basedir=&quot;F:/mysql-8.0.23&quot;# 数据保存位置datadir=&quot;F:/mysql-8.0.23/data&quot;# 允许最大连接数max_connections=100# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=3# 服务端使用的字符集默认为UTF8（UTF8MB3）character-set-server=utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password 说明：根据自己的安装目录，更改basedir和datadir；在mysql编码中，utf8mb4才是真正的utf-8，用4个字节存储中文。 启动服务 123456789# 初始化# 此处会给出root的初始化密码（暂存，后面有用）mysqld --initialize --console# 安装mysqlmysqld --install# windows启动mysql服务，停止：net stop mysql;删除：mysqld -remove mysqlnet start mysql# 查看windows服务启动状况services.msc 初始化root密码 1234# 输入刚才的密码mysql -u root -p# 修改root密码alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;新密码&#x27;; 问题及解决方法 运行mysqld --install，报“无法启动此程序，因为计算机丢失VCRUNTIME140_1.dll。” 下载一个微软常用运行库合集，运行一下即可。安装包在百度云盘中。 navicat for mysql 15破解 准备资源 下载navicat for mysql 15 官网地址：http://www.navicat.com.cn/download/navicat-for-mysql 下载注册机 百度网盘：Navicat Keygen Patch v5.6.0 DFoX.exe 破解步骤 安装navicat for mysql，确认安装目录后，一直根据提示确认即可。 将注册机文件复制到navicat for mydql的安装目录 打开注册机： 待续。。。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://yclii.github.io/workbook/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://yclii.github.io/workbook/tags/mysql/"}]},{"title":"信贷核算晚间批量性能优化思路分享","slug":"信贷核算晚间批量性能优化思路分享","date":"2021-05-07T12:34:42.000Z","updated":"2022-01-10T00:30:35.695Z","comments":true,"path":"2021/05/07/信贷核算晚间批量性能优化思路分享/","link":"","permalink":"https://yclii.github.io/workbook/2021/05/07/%E4%BF%A1%E8%B4%B7%E6%A0%B8%E7%AE%97%E6%99%9A%E9%97%B4%E6%89%B9%E9%87%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB/","excerpt":"","text":"信贷核算晚间批量性能优化思路分享 交付一总部 | 李一称 2021.05 [toc] 项目背景系统名称：XX银行零售信贷系统 系统特性：拥有独立核算功能 业务数据：基础业务数据单表百万级 晚间批量：Java程序，公司批量框架，日批 软件版本：JDK7、Oracle11g、ALS7 运行状况：晚间批量整体执行耗时超过允许的最大阈值范围（晚10点-明早7点） 优化目标现状：晚间批量整体运行结束时间超过了早上7点 目标：晚间批量整体运行结束时间控制在在凌晨5点之前 优化对象因晚间批量为日批，且每天都表现的很慢，就抓取了昨晚的批量任务单元执行日志表（AWE_TASK_INFO，主要包括任务单元编号、名称、开始时间、结束时间等）中的执行时长，快速筛选大于阈值（10 min）的任务单元，计划为本次优化的对象。当时排在TOP5的单元都在30min以上，且TOP1的耗时达到了近90min。 代码分析说明：文档中涉及的代码（包括类名）均为伪代码，但可以表达出实际项目的大致实现。 所有的任务单元处理类均继承了AbstractLoanTask.java，该类采用了模板方法的设计模式，基本结构及实现逻辑如下： 1234567891011121314151617181920212223242526272829303132333435363738/*** 执行入口*/public int execute() throws Exception &#123; try &#123; before(); run(); after(); &#125; catch (Exception e) &#123; //异常处理、日志记录 ... &#125; finally &#123; //资源释放 ... &#125; &#125;/*** 1、初始化当前实例业务属性* 2、初始化数据库连接* 3、初始化当前任务单元执行日志开始信息*/public void before() throws Exception &#123; ...&#125;/*** 业务处理主体，待具体单元实现*/public abstract void run() throws Exception;/*** 业务处理后续逻辑，如更新当前任务单元执行日志结束信息*/public void after() throws Exception &#123; ...&#125; 数据访问层做了一个基类（BasicDao.java）的封装，实现的公共功能大致有： 方法 说明 BizObject findObjectByKey(DataElement key) 根据业务主键获取业务对象 List&lt;BizObject&gt; findObjectsByObjectNo(DataElement objectNo) 根据关联对象编号获取业务对象集合 当然还有一些更新的方法 持久层做了一个Model基类（BasicModel）,包含的属性大致有： 属性 说明 BizObject value 当前业务对象 List&lt;BizObject&gt; relativeObjects 关联的业务对象 List&lt;BizObject&gt; deleteObjects 待删除的业务对象 List&lt;BizObject&gt; insertObjects 待保存的业务对象 List&lt;BizObject&gt; updateObjects 待更新的业务对象 在对当前业务对象及相关联对象进行保存或更新时，会依次解析deleteObjects、insertObjects、updateObjects成带有变量绑定的sql语句，如delete、insert、update语句。 晚间核算，如一般贷款还款批量（TOP1就是它）、提前还款批量，大致的数据流结构如下： 分析结果 单线程，无法获取多核cpu的计算效率。（linux系统通过top命令查看） 主表记录以及级联的业务记录均在jvm中实例化后参与核算，导致内存可能消耗会很快。 核算逻辑在java逻辑中，性能瓶颈很大可能在jvm优化层面上。 AWR报告分析 关注点 AWR报告采用总分的形式，前面是系统的整体情况，后面是各个部分细节，一开始不要陷入细节，先分析系统的整体状况，对于后面的专题分析，要根据关注点的不同，采取跳跃式分析。还要根据具体业务的不同，决定某种现象是否正常。 根据代码的分析，核算的业务逻辑大都是基于主表记录的迭代，通过关联流水号查询其相关的业务表记录。表现出大量相同sql的频繁执行，所以在分析AWR报告时可以关注以下几点： Load Profile：了解系统整体负载状况，如每秒中的事务数/语句数，每秒/每事务物理读写次数(Physical Reads/Writes), 逻辑读写次数(Logical Reads/Writes)，SQL语句的解析(Parse)，特别是硬解析的次数（per second或per transaction），硬解析太多，说明SQL重用率不高，一般是应用程序sql没有做变量绑定处理。 Instance Efficiency Percentages： 各指标都应接近100%，如： Library Hit 表示从Library Cache中检索到一个解析过的SQL或PL/SQL语句的比率，当应用程序调用SQL或存储过程时，Oracle检查Library Cache确定是否存在解析过的版本，如果存在，Oracle立即执行语句；如果不存在，Oracle解析此语句，并在Library Cache中为它分配共享SQL区。低的library hit ratio会导致过多的解析，增加CPU消耗，降低性能。如果library hit ratio低于90%，可能需要调大shared pool区。 Latch Hit Latch是一种保护内存结构的轻量级锁，可以认为是进程获取访问内存数据结构的许可。要确保Latch Hit&gt;99%，否则意味着Shared Pool latch争用，可能由于未共享的SQL，或者Library Cache太小，可使用绑定变更或调大Shared Pool解决。 Top 5 Timed Events： 这里列出消耗时间最多的5个等待事件，每种等待说明，都表示一种原因，如：db file sequential read表示按索引（索引选择性差）访问出现等待；db file scattered read表示全表扫描访问出现等待事件；db file parallel write 表示I/O负载高，可以通过设置db_writer_processes来提高DBWR进程数量。 TopNSQL： 根据时间消耗，内存消耗，物理I/O等排序，对相关SQL分析执行计划。 生成AWR报告 sqlplus / as sysdba @?/rdbms/admin/awrrpt.sql 输入 html –这是选择awr的查看方式网页方式（默认）或者txt 输入天数 –一般是1-8的数字，1就代表当天的（Oracle10g默认保留7天快照、11g默认保留8天快照，但可以手工设置） 输入开始快照ID 输入结束快照ID 输入保存文件名称 –例如 awr-20210101.html 回车 分析结果 因核算代码数据访问层对sql进行了统一的转换和处理，且做了变量绑定，一般硬解析次数会很正常；sql查询或更新都是根据相关流水号做的单张表单条记录的更新，一般流水号字段都会添加索引，个人认为数据库优化的空间不大，除了一些数据库硬件瓶颈。 JVM内存分析 关注点 因对cpu的使用不够，初步采用多线程设计势在必行。但是，设置多少个线程合适？因核算逻辑集中的java代码中处理，每个业务对象及其关联的业务对象都会被实例化一个个对象，且为了满足业务对象的普适性，一般都会做“select * from T”，即查询所有字段。本来就会消耗了“多余”的内存，这时候再做多线程处理，若线程数设置的不合理，会直接导致内存的快速增长，OOM现象会很容易出现。 此时，需要关注以下3个要素，以达到平衡： Xmx 进程的最大堆内存 Pagesize 进程处理的主表业务记录数 Threads 线程数 内存模型 方法区（线程共享） 被所有方法线程共享的一块内存区域。用于存储已经被虚拟机加载的类信息，常量，静态变量等。这个区域的内存回收目标主要针对常量池的回收和堆类型的卸载。 堆（线程共享） 被所有线程共享的一块内存区域，在虚拟机启动的时候创建，用于存放对象实例。当堆中没有内存可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。 Java栈（线程私有） 每个方法在执行的时候也会创建一个栈帧，存储了局部变量，操作数，动态链接，方法返回地址。每个方法从调用到执行完毕，对应一个栈帧在虚拟机栈中的入栈和出栈。通常所说的栈，一般是指在虚拟机栈中的局部变量部分。如果线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常。 本地方法栈（线程私有） 和Java栈类似，主要为虚拟机使用到的Native方法服务。也会抛出StackOverflowError 异常。 程序计数器（线程私有） 执行Java方法时，计数器记录的是虚拟机字节码指令的地址(当前指令的地址)。 堆分代 几乎所有的Java对象实例都放在Java堆中。这也就意味着，堆中对象分配和回收将是JVM的处理重点！为了更好的处理这些对象，JVM便将Java堆分成几块区域。由于根据对象存活的周期不同，所以称之为新生代、老年代和永久代（JDK1.8起被移除，添加了元空间的概念）。 新生代内存按照8:1:1的比例分为一个eden区和两个survivor区。大部分对象在eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。 说明：参数均可以调整，默认参数可以用java -XX:+PrintFlagsInitial查看 分析工具jstat 可以实时监控堆的使用情况： 查看新生代、老生代及元空间的容量及使用情况 查看新生代、老生代及元空间的垃圾收集情况，包括垃圾回收的次数及垃圾回收所占用的时间 gc实时统计命令： jstat -gcutil 进程ID 3000 列名 说明 S0 Heap上的 Survivor space 0 区已使用空间的百分比 S1 Heap上的 Survivor space 1 区已使用空间的百分比 E Heap上的 Eden space 区已使用空间的百分比 O Heap上的 Old space 区已使用空间的百分比 M Metaspace 区已使用空间的百分比 CCS 压缩类空间的百分比 YGC 从应用程序启动到采样时发生 Young GC 的次数 YGCT 从应用程序启动到采样时 Young GC 所用的时间(单位秒) FGC 从应用程序启动到采样时发生 Full GC 的次数 FTCT 从应用程序启动到采样时 Full GC 所用的时间(单位秒) GCT 从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC 参数调整 已知Xmx=2048M，PageSize=2000，业务数据来源于模拟生产数据量，以减少FGC、FTCT，GCT为目的，多次测试，取得优化后的线程数Threads。此外，多进程的配合，可以强迫式减少GC时间，这取决于初始化一个虚拟机进程以及内部相关初始化服务付出的时间代价与后期GC时间的权衡。一般的，晚间批量进程服务少，启动都很快，可以考虑支持多进程。 优化思路 增加多进程多线程代码增强处理，提高应用cpu利用率。 借助jstat工具调整配置参数，避免频繁的gc。 借助AWR报告，找出是否有明显的性能瓶颈。 多进程多线程 MPMT（Multiple Progresses Multiple Threads）流程图 基类AbstractLoanTask代码增强 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * 批处理基类 */public abstract class AbstractTaskBatch extends ExecuteUnit &#123; //执行状态 protected AtomicInteger executeStatus = new AtomicInteger(TaskConstants.ES_SUCCESSFUL); //主表查询sql protected String querySql; //是否多进程 protected boolean multiProgresses; //是否多线程 protected boolean multiThreads; //初始化进程数 protected int progresses; //每个进程分配的业务记录数 protected int pageSize; //每个进程分配的堆内存（单位M） protected int xmx; ... /** * 多线程业务处理 * @param valuePools 参数池 * @param group 线程组 * @param thread 处理线程 * @throws Exception */ protected void executeBatchThread(ASValuePool[] valuePools,ThreadGroup group,BatchThread thread) throws Exception &#123; if(!ArrayUtils.isEmpty(valuePools))&#123; if(this.multiThreads &amp;&amp; this.threadsPerProgress &gt;0 &amp;&amp; valuePools.length &gt; 1)&#123; for(ASValuePool valuePool:valuePools)&#123; BatchThread clone = (BatchThread)thread.clone(); clone.valuePool = valuePool; new Thread(group,clone).start(); &#125; while(group.activeCount() &gt;0)&#123; //halt 表示线程组存在失败的线程是否终其他线程的执行 if(this.halt &amp;&amp; this.executeStatus.get() == TaskConstants.ES_FAILED)&#123; group.interrupt(); &#125; &#125; &#125;else&#123; for(ASValuePool valuePool:valuePools)&#123; thread.valuePool = valuePool; thread.run(); &#125; &#125; &#125; &#125; /** * 多线程处理器 */ protected abstract class BatchThread implements Runnable,Cloneable &#123; //输入参数 public ASValuePool valuePool; @Override protected Object clone() throws CloneNotSupportedException &#123; // TODO Auto-generated method stub return super.clone(); &#125; @Override public void run() &#123; // TODO Auto-generated method stub Connection connection = null; try &#123; ARE.getDBConnection(database); execute(connection); &#125; catch (Throwable t) &#123; executeStatus.set(TaskConstants.ES_FAILED); ARE.getLog().error(&quot;Thread[&quot; + this.getName() + &quot;] execute error&quot;, t); &#125;finally&#123; if(connection != null) connection.close(); &#125; &#125; public abstract void execute(Connection connection) throws Throwable; &#125; &#125; shell脚本 1234567891011121314151617181920212223242526272829303132#!/bin/shtask=$1target=$2unit=$3range=$4xmx=$5if [ -z &quot;$xmx&quot; ]; then xmx=1024ficd `dirname $0`export LANG=zh_CN.UTF-8if [ -z &quot;$JAVA_HOME&quot; ]; then echo &quot;environment variable JAVA_HOME missed,please check!&quot;image-20220106222420591 exit 1ficd ..CLASSPATH=.$&#123;JAVA_HOME&#125;/jre/lib/rt.jar:./classesJLIBDIR=./libexport JLIBDIRfor LL in `ls $JLIBDIR/*.jar`do CLASSPATH=$CLASSPATH:$LLdoneexport CLASSPATHexport JAVA_OPTION=&quot;-Dfile.encoding=UTF-8 -xms$&#123;xmx&#125;M -Xmx$&#123;xmx&#125;M&quot;export RUN_CLASS=com.amarsoft.task.SlaveProgressExecutortaskInfo=&quot;task=$&#123;task&#125; target=$&#123;target&#125; unit=$&#123;unit&#125; range=$&#123;range&#125;&quot;i=`$&#123;JAVA_HOME&#125;/bin/java $&#123;JAVA_OPTION&#125; -classpath $&#123;CLASSPATH&#125; $&#123;RUN_CLASS&#125; $&#123;taskInfo&#125;`exit i 从进程任务执行器，SlaveProgressExecutor.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void main(String[] args) &#123; CommandLineArgument arguments = new CommandLineArgument(args); String are = arguments.getArgument(&quot;are&quot;); if (are != null) ARE.init(are); else ARE.init(); String taskFile = arguments.getArgument(&quot;task&quot;, ARE.getProperty(&quot;taskFile&quot;)); notNull(taskFile,&quot;没有定义任务配置文件！&quot;); String sTarget = arguments.getArgument(&quot;target&quot;); notNull(sTarget,&quot;没有定义target参数！&quot;); String sUnit = arguments.getArgument(&quot;unit&quot;); notNull(sUnit,&quot;没有定义unit参数！&quot;); Task task = TaskBuilder.buildTaskFromXML(taskFile); notNull(task,&quot;创建任务失败！&quot;); Target target = task.getTarget(sTarget); notNull(task,&quot;获取target失败！&quot;); ExecuteUnit unit = target.getUnit(sUnit); notNull(unit,&quot;获取unit失败！&quot;); //业务数据范围，格式：A~#~B unit.setProperty(&quot;multi.range&quot;, arguments.getArgument(&quot;range&quot;)); //标识当前进程为从进程 unit.setProperty(&quot;multi.slave&quot;, &quot;true&quot;); //status 成功返回0 失败返回1 int status = unit.execute(); if(status == TaskConstants.ES_SUCCESSFUL) status = 0; else status = 1; System.exit(status);&#125; /** * 对象为空处理 * * @param object * @param message*/private static void notNull(Object object,String message) &#123; if(object == null) &#123; ARE.getLog().error(message); System.exit(1);//执行失败，返回码1 &#125;&#125; 项目总结 从工程代码结构出发，快速抓住了性能瓶颈（cpu资源利用不足）。 对代码进行了横切增强，更重要的是没有对核算逻辑（不敢动）造成侵害。 考虑到了gc因素，通过gc监控，使参数达到最优，且参数均可配置，建议后期维护可以定期收集gc统计日志，对应调整参数。 优化的还算成功，top1的一般还款由原先的90min降到了10min以内。 这是我的第一个性能优化类项目，肯定有没有考虑周全的地方，日后发现改进补充。 st=>start: 开始 op=>operation: 获取主表（如借据表）结果集并遍历 op2=>operation: 遍历中获取每条主表记录并级联获取关联对象，多级关联。 op3=>operation: 执行具体核算逻辑更新相关业务对象及数据库表记录 e=>end: 结束 st->op op->op2 op2->op3 op3->e{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://yclii.github.io/workbook/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"AWR","slug":"AWR","permalink":"https://yclii.github.io/workbook/tags/AWR/"},{"name":"JVM","slug":"JVM","permalink":"https://yclii.github.io/workbook/tags/JVM/"},{"name":"多进程","slug":"多进程","permalink":"https://yclii.github.io/workbook/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"},{"name":"多线程","slug":"多线程","permalink":"https://yclii.github.io/workbook/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]}],"categories":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://yclii.github.io/workbook/categories/HTTPS/"},{"name":"devOpts","slug":"devOpts","permalink":"https://yclii.github.io/workbook/categories/devOpts/"},{"name":"tool","slug":"tool","permalink":"https://yclii.github.io/workbook/categories/tool/"},{"name":"oracle","slug":"oracle","permalink":"https://yclii.github.io/workbook/categories/oracle/"},{"name":"vscode","slug":"vscode","permalink":"https://yclii.github.io/workbook/categories/vscode/"},{"name":"maven","slug":"maven","permalink":"https://yclii.github.io/workbook/categories/maven/"},{"name":"vue","slug":"vue","permalink":"https://yclii.github.io/workbook/categories/vue/"},{"name":"mysql","slug":"mysql","permalink":"https://yclii.github.io/workbook/categories/mysql/"},{"name":"性能优化","slug":"性能优化","permalink":"https://yclii.github.io/workbook/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"SSL,TLS,OpenSSL","slug":"SSL-TLS-OpenSSL","permalink":"https://yclii.github.io/workbook/tags/SSL-TLS-OpenSSL/"},{"name":"docker","slug":"docker","permalink":"https://yclii.github.io/workbook/tags/docker/"},{"name":"mermaid","slug":"mermaid","permalink":"https://yclii.github.io/workbook/tags/mermaid/"},{"name":"git","slug":"git","permalink":"https://yclii.github.io/workbook/tags/git/"},{"name":"oracle","slug":"oracle","permalink":"https://yclii.github.io/workbook/tags/oracle/"},{"name":"AWR","slug":"AWR","permalink":"https://yclii.github.io/workbook/tags/AWR/"},{"name":"vscode","slug":"vscode","permalink":"https://yclii.github.io/workbook/tags/vscode/"},{"name":"vue","slug":"vue","permalink":"https://yclii.github.io/workbook/tags/vue/"},{"name":"maven","slug":"maven","permalink":"https://yclii.github.io/workbook/tags/maven/"},{"name":"mysql","slug":"mysql","permalink":"https://yclii.github.io/workbook/tags/mysql/"},{"name":"JVM","slug":"JVM","permalink":"https://yclii.github.io/workbook/tags/JVM/"},{"name":"多进程","slug":"多进程","permalink":"https://yclii.github.io/workbook/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"},{"name":"多线程","slug":"多线程","permalink":"https://yclii.github.io/workbook/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]}