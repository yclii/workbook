{"meta":{"title":"李一称的博客","subtitle":"","description":"","author":"ycli","url":"https://yclii.github.io/workbook","root":"/workbook/"},"pages":[{"title":"关于","date":"2021-05-07T04:14:44.000Z","updated":"2021-10-27T11:13:08.611Z","comments":true,"path":"about/index.html","permalink":"https://yclii.github.io/workbook/about/index.html","excerpt":"","text":"关于我追求新技术，有代码洁癖，爱琢磨。 关于工作城市：武汉 关于学习一直在不停的学习中…近期学习方向：区块链 关于座右铭 Knowledge is the torch of wisdom.（知识是智慧的火炬） 关于爱好读书、动漫、篮球、静静"},{"title":"categories","date":"2021-05-06T18:45:28.000Z","updated":"2021-10-27T11:13:08.622Z","comments":true,"path":"categories/index.html","permalink":"https://yclii.github.io/workbook/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-05-06T20:25:35.000Z","updated":"2021-10-27T11:13:08.622Z","comments":true,"path":"tags/index.html","permalink":"https://yclii.github.io/workbook/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"深入浅出https从原理到实践学习笔记","slug":"深入浅出https从原理到实践学习笔记","date":"2021-12-29T19:32:40.000Z","updated":"2021-12-29T07:53:02.263Z","comments":true,"path":"2021/12/29/深入浅出https从原理到实践学习笔记/","link":"","permalink":"https://yclii.github.io/workbook/2021/12/29/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAhttps%E4%BB%8E%E5%8E%9F%E7%90%86%E5%88%B0%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1. HTTP介绍1.1 几个概念 web(万维网)，是互联网的一个子应用，主要包括3项技术：HTML、URL、HTTP HTTP(超文本传输协议)，由一系列规则组成，客户端和服务端共同处理这些规则，HTTP不仅定义规则，也是信息的载体 URL(统一资源标识符)，可唯一定位或标识互联网上的任何资源 HTML(超文本标记语言)，客户端(浏览器)通过HTTP接收的资源一般是HTML，HTML定义了一系列规则，规则主要有客户端进行解析。 1.2 HTTP版本目前版本HTTP/1.1，基于RFC2616规范，相比HTTP/0.9、HTTP/1.0，HTTP/1.1并没有太多的演变，但从性能和标准化的维度做了些优化；HTTP/2.0是下一代标准。 1.2 HTTP语义 HTTP消息包括HTTP语义和HTML实体 HTTP消息包括3部分：请求行或响应行、HTTP头部（可以多个）、HTML实体(请求实体和响应实体) 请求行由方法、URL、HTTP版本组成（如：GET /index.html HTTP/1.1）；响应行由HTTP版本、状态码、信息提示符组成（如：HTTP/1.1 200 OK） HTTP语义的重点是HTTP头部(HTTP Header)，约束客户端或服务端行为（如Accept-Encoding:gzip，表示浏览器支持的数据压缩算法是gzip，告诉服务器是否可以使用gzip算法压缩响应；Host:www.baidu.com，该头部只对客户端有用，客户端在连接前需要通过DNS解析出IP地址，然后连接服务器发送请求） 1.3 HTTP特点 HTTP特点：无状态、跨平台 HTTP协议处于网络模型的应用层，默认端口80 1.4 HTTP不安全原因HTTP在设计之处根本没有考虑安全问题，其设计目的是数据传输与共享。 HTTP不安全的原因主要包括以下3点： 数据没有加密 无法验证身份 数据易篡改 1.5 攻击方式​ SQL注入、XSS、Dos(DDos) 1.6 缓解安全问题的措施W3C制定Web技术标准，如HTML标准、DOM标准、CSS标准、ECMAScript标准、HTML5标准。 W3C主要以HTTP头部的方式提供安全保护，以环节安全问题，如Access-Control-Allow-Origin、X-XSS-Protection、Strict-Transport-Security、Content-Security-Policy等等，如XSS攻击，服务器声明头部Content-Security-Policy，告诉浏览器只允许加载本域下的脚本文件，就能避免跨站脚本攻击。 2. 密码学HTTPS的本质就是对密码学算法的组合使用 2.1 密码学的四个目标 机密性(隐私性) 完整性 身份验证 不可抵赖性 2.2 OpenSSLOpenSSL是密码学中一个非常流行的底层密码库 查看OpenSSL版本 1openssl version 查看所有支持的命令 1openssl help 获取算法的帮助信息 1openssl rsa --help 获取算法详细使用信息 1man rsa 构建特定版本的openssl 1234567891011121314151617# 示例：构建OpenSSL-1.1.0f，避免和系统的OpenSSL库冲突# 下载二进制包并解压wget https://www.openssl.org/source/openssl-1.1.0f.tar.gztar -xvf openssl-1.1.0f.tar.gzcd openssl-1.1.0f# 查看安装手册more INSTALL# 查看config./config --help# 安装并编译，安装目录不要和系统目录冲突（可以查看系统的安装目录 which openssl）./config --prefix=/usr/local/openssl --openssldir=/usr/local/opensslmakemake testmake installmake clean# 验证/usr/local/openssl/bin/openssl version 2.3 随机数 随机数类型","categories":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://yclii.github.io/workbook/categories/HTTPS/"}],"tags":[{"name":"SSL,TLS,OpenSSL","slug":"SSL-TLS-OpenSSL","permalink":"https://yclii.github.io/workbook/tags/SSL-TLS-OpenSSL/"}]},{"title":"Docker技术入门与实践学习笔记","slug":"Docker技术入门与实践学习笔记","date":"2021-06-23T15:25:08.000Z","updated":"2021-10-30T09:00:54.250Z","comments":true,"path":"2021/06/23/Docker技术入门与实践学习笔记/","link":"","permalink":"https://yclii.github.io/workbook/2021/06/23/Docker%E6%8A%80%E6%9C%AF%E5%85%A5%E9%97%A8%E4%B8%8E%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"概述 Docker 是一个基于Go语言实现的开源应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux 或 Windows 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。 历史 Docker 是 PaaS 提供商 dotCloud 开源的一个基于 LXC 的高级容器引擎，源代码托管在 Github 上, 基于go语言并遵从Apache2.0协议开源。 诞生于2013年年初，发起者是dotCloud公司。2013年年底，dotCloud公司直接改名为Docker Inc，专注于Docker相关技术和产品的开发，目前已成为全球最大的Docker容器服务提供商。官网：docker.com 2014年，Docker镜像下载数达到了一百万次，2015年，突破十亿次，2017年，突破百亿次。 目前主流的操作系统，包括Linux各大发行版、macOS、Windows等都已经支持Docker。 优势 应用直接运行在底层操作系统上，无法保证同一份应用在不同环境行为一致。Docker通过容器来打包应用，解耦了应用和运行平台。 Docker可以快速创建和删除容器，实现快速的交付和部署。 Docker是内核级的虚拟化，不需要额外的虚拟化管理程序（Virtual Machine Manager，VMM，以及Hypervisor）的支持，可以更高效的利用资源。 Docker与虚拟化 在计算机技术中，虚拟化是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以用比原来的组态更好的方式来应用这些资源。 虚拟化的核心是对资源的抽象，一般为了在同一个主机上同时运行多个系统或应用，从而提高系统资源的利用率，并且能降低成本、方便管理和容错容灾。 虚拟化技术分类： 基于硬件 真正基于硬件的不多，少数如网卡中的单根多IO虚拟化技术 基于软件 2.1 应用虚拟化 一般指的是一些模拟设备或诸如Wine的软件 2.2 平台虚拟化 完全虚拟化 虚拟机模拟完整的底层硬件环境。如IBM p和z系列的虚拟化、VMware Workstation、VirtualBox、QEMU等 硬件辅助虚拟化 利用硬件（主要是CPU）辅助支持（目前X86体系结构上可用的硬件辅助虚拟化技术包括Intel-VT和AMD-V）处理敏感指令来实现完全虚拟化的功能。如VMware Workstation、Xen、KVM等 部分虚拟化 只针对部分硬件资源进行虚拟化 超虚拟化 部分硬件接口以软件的形式提供给客户机操作系统，客户操作系统需要进行修改。如早期的Xen 操作系统级虚拟化 内核通过创建多个虚拟的操作系统实例（内核和库）来隔离不同的进程。容器相关的技术就在这个范畴。 与传统虚拟机技术的比较： 特性 容器 虚拟机 启动速度 秒级 分钟级 性能 接近原生 较弱 内存代价 很小 较多 硬盘使用 一般为MB 一般为GB 运行密度 单机支持上千个容器 一般几十个 隔离性 安全隔离 完全隔离 迁移性 优秀 一般 传统方式是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统层。 Docker容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，因此更加轻量。 核心概念Docker 的 3 大核心概念：镜像、容器、仓库。 镜像Docker 镜像由多个层组成，每层叠加后，从外部看就如一个独立的对象。镜像内部是一个精简的操作系统，同时包含应用运行所必需的文件和依赖包。镜像类比于VM模板或类（Class）文件。 镜像通常比较小，构建镜像时通常会裁剪掉不必要的部分，镜像不包含容器共享的主机内核，仅包含必要的操作系统（操作系统文件和文件系统对象）。 容器Docker 容器类似于一个轻量级沙箱，用于隔离和运行应用。 仓库Docker 集中存放镜像文件的地方。常见的镜像仓库是 Docker Hub 安装 Docker引擎https://www.docker.com/get-docker","categories":[{"name":"devOpts","slug":"devOpts","permalink":"https://yclii.github.io/workbook/categories/devOpts/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://yclii.github.io/workbook/tags/docker/"}]},{"title":"mermaid使用手册","slug":"mermaid使用手册","date":"2021-05-21T19:44:56.000Z","updated":"2021-10-27T11:13:08.610Z","comments":true,"path":"2021/05/21/mermaid使用手册/","link":"","permalink":"https://yclii.github.io/workbook/2021/05/21/mermaid%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","excerpt":"","text":"概述 It is a Javascript based diagramming and charting tool that renders Markdown-inspired text definitions to create and modify diagrams dynamically. 它是一个基于Javascript的图表和坐标图工具，可以呈现基于Markdown的文本定义来动态地创建和修改图表。 安装 官网地址：https://mermaid-js.github.io/mermaid/#/ 源码安装（在线编辑） git clone https://github.com/mermaid-js/mermaid-live-editor.git 进入目录后，npm install，然后启动 npm run dev。 发布版安装 npm init npm install -S mermaid 新建一文本，写入mermaid组件语句，如： 123456789101112131415ganttdateFormat YYYY-MM-DDtitle 项目交付计划 section 里程碑 0.1 数据库设计:active,p1,2016-08-15,3d详细设计:p2,after p1,2d section 里程碑 0.2后端开发:p3,2016-08-22,20d前端开发:p4,2016-08-22,15d section 里程碑 0.3功能测试:p6,after p3,5d上线:p7,after p6,2d 命名为demo.gantt，然后使用一下命令： 1mermaid demo.gantt -w 1920 -s -p -o images 就会在images目录下生成两个文件，一个svg文件、一个png图片文件。 1234-s --svg 输出 SVG 替代 PNG（试验性的功能）。-p --png 如果选择保存 SVG，那么加上这个选项可以同时保存 PNG。-o --outputDir 保存文件的目录（如果不存在会自动创建），默认 `cwd`。-w --width 生成的图片宽度 typora插件（安装typora即可） typora工具默认集成了mermaid，使用&lt;pre class=&quot;mermaid&quot;&gt;即可开启mermaid功能。刻意输入不合法的语法，即可显示当前mermaid版本。 ==说明：本文档所有示例采用第三种，typora插件== 图表类型流程图（FlowChart） All Flowcharts are composed of nodes, the geometric shapes and edges, the arrows or lines. The mermaid code defines the way that these nodes and edges are made and interact. 流程图就是一些节点、几何图形、边界、箭头和线条的组合。 graph语句 流程图是从graph语句开始，graph语句表示流程图的方向，默认是从top到bottom（TD或TB）。可能的方向包括： 方向 说明 TB top to bottom TD top-down，等同于TB BT bottom to top RL right to left LR left to right 默认节点 1234567891011graph TB ID&lt;/pre&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph TB ID&lt;/pre&gt;```markdowngraph TB ID[hello] graph TB ID[hello] 12graph TB ID(hello) graph TB ID(hello) 12graph TB ID([hello]) graph TB ID([hello]) 12graph TB ID((hello)) graph TB ID((hello)) 12graph TB ID[[hello]] graph TB ID[[hello]] 12graph TB ID[(hello)] graph TB ID[(hello)] 12graph TB ID&gt;hello] graph TB ID>hello] 12graph TB ID&#123;hello&#125; graph TB ID{hello} 12graph TB ID&#123;&#123;hello&#125;&#125; graph TB ID 12graph TB ID[/hello/] graph TB ID[/hello/] 12graph TB ID[\\hello/] graph TB ID[\\hello/] 12graph TB ID[/hello\\] graph TB ID[/hello\\] 连线 12graph LR A--&gt;B graph LR A-->B 12graph LR A--hello--&gt;B graph LR A--hello-->B 12graph LR A--&gt;|hello|B graph LR A-->|hello|B 12graph LR A---B graph LR A---B 12graph LR A--hello---B graph LR A--hello---B 12graph LR A---|hello|B graph LR A---|hello|B 12graph LR A-.-&gt;B graph LR A-.->B 12graph LR A-.hello.-&gt;B graph LR A-.hello.->B 12graph LR A-.-&gt;|hello|B graph LR A-.->|hello|B 12graph LR A-.-B graph LR A-.-B 12graph LR A-.hello.-B graph LR A-.hello.-B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A==&gt;B graph LR A==>B 12graph LR A==hello==&gt;B graph LR A==hello==>B 12graph LR A==&gt;|hello|B graph LR A==>|hello|B 12graph LR A--&gt;|hello|B--&gt;|hello|C graph LR A-->|hello|B-->|hello|C 12graph LR A--&gt;|hello|B &amp; C--&gt;D graph LR A-->|hello|B & C-->D 12graph A &amp; B --&gt; C &amp; D graph A & B --> C & D 123456graph A[开始]--&gt;B&#123;Yes or No?&#125; B--&gt;|Yes|C[OK] C--&gt;D[Rethink] D--&gt;B B--&gt;|No|E[结束] graph LR A[开始]-->B{Yes or No?} B-->|Yes|C[OK] C-->D[Rethink] D-->B B-->|No|E[结束] 含有特殊字符的字符串需要用双引号 12graph A[&quot;hello(world)&quot;] graph A[\"hello(world)\"] Subgraphs 语法格式： 123subgraph title graph definitionend 12345678910graph TB subgraph one A1--&gt;A2 end subgraph two B1--&gt;B2 end subgraph three C1-&gt;C2 end graph TB A1-->C2 subgraph three C1-->C2 end subgraph two B1-->B2 end subgraph one A1-->A2 end 样式 1234graph LR id1(Start)--&gt;id2(Stop) style id1 fill:#f9f,stroke:#333,stroke-width:4px style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5 graph LR id1(Start)-->id2(Stop) style id1 fill:#f9f,stroke:#333,stroke-width:4px style id2 fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5 时序图（Sequence） A Sequence diagram is an interaction diagram that shows how processes operate with one another and in what order. 时序图就是用来展示进程间按照某种排序进行交互的图形 12345sequenceDiagram autonumber 张三-&gt;&gt;李四: Hello 李四, how are you? 李四--&gt;&gt;张三: Great! 张三--&gt;&gt;李四: See you later! sequenceDiagram autonumber 张三->>李四: Hello 李四, how are you? 李四-->>张三: Great! 张三-->>李四: See you later! 123456sequenceDiagram participant A as 张三 participant B as 李四 A-&gt;&gt;B: Hello 李四, how are you? B-xA: Great! A--xB: See you later! sequenceDiagram participant A as 张三 participant B as 李四 A->>B: Hello 李四, how are you? B-xA: Great! A--xB: See you later! 12345678sequenceDiagram participant A as 张三 participant B as 李四 A-&gt;&gt;B: Hello 李四, how are you? activate B B-xA: Great! deactivate B A--xB: See you later! sequenceDiagram participant A as 张三 participant B as 李四 A->>B: Hello 李四, how are you? activate B B-xA: Great! deactivate B A--xB: See you later! 123456sequenceDiagram participant A as 张三 participant B as 李四 A-&gt;&gt;+B: Hello 李四, how are you? B-x-A: Great! A--xB: See you later! sequenceDiagram participant A as 张三 participant B as 李四 A->>+B: Hello 李四, how are you? B-x-A: Great! A--xB: See you later! 1234567sequenceDiagram participant A as 张三 participant B as 李四 note right of B: 我是李四 A-&gt;&gt;B: Hello 李四, how are you? B--&gt;&gt;A: Great! A--&gt;&gt;B: See you later! note right of|left of|over sequenceDiagram participant A as 张三 participant B as 李四 note right of B: 我是李四 A->>B: Hello 李四, how are you? B-->>A: Great! A-->>B: See you later! 12345678sequenceDiagram autonumber participant A as 张三 participant B as 李四 note over A,B: 张三，李四 A-&gt;&gt;B: Hello 李四, how are you? B--&gt;&gt;A: Great! A--&gt;&gt;B: See you later! sequenceDiagram autonumber participant A as 张三 participant B as 李四 note over A,B: 张三，李四 A->>B: Hello 李四, how are you? B-->>A: Great! A-->>B: See you later! 1234567sequenceDiagram participant A as 张三 participant B as 李四 A-&gt;&gt;B: Hello 李四, how are you? loop 每个一分钟 B--&gt;&gt;A: Great! end sequenceDiagram participant A as 张三 participant B as 李四 A->>B: Hello 李四, how are you? loop 每个一分钟 B-->>A: Great! end 123456789101112sequenceDiagram participant A as 张三 participant B as 李四 A-&gt;&gt;B: Hello 李四, how are you? alt 感冒了 B--&gt;&gt;A: 感冒了:( else 很好 B--&gt;&gt;A: 吃嘛嘛香:) end opt 额外的响应 B--&gt;&gt;A: 谢谢关心！ end sequenceDiagram participant A as 张三 participant B as 李四 A->>B: Hello 李四, how are you? alt 感冒了 B-->>A: 感冒了:( else 很好 B-->>A: 吃嘛嘛香:) end opt 额外的响应 B-->>A: 谢谢关心！ end 12graph LR A-.-|hello|B sequenceDiagram participant A as 张三 participant B as 李四 participant C as 王五 par 张三 to 李四 A-->>B: 最近咋样？ and 张三 to 王五 A-->>C: 最近咋样？ end 12345678910111213141516sequenceDiagram participant A as 张三 participant B as 李四 rect rgba(153,50,204,.9) A-&gt;&gt;B: Hello 李四, how are you? alt 感冒了 B--&gt;&gt;A: 感冒了:( else 很好 B--&gt;&gt;A: 吃嘛嘛香:) end end rect rgba(255,0,255) opt 额外的响应 B--&gt;&gt;A: 谢谢关心！ end end sequenceDiagram participant A as 张三 participant B as 李四 rect rgba(153,50,204,.9) A->>B: Hello 李四, how are you? alt 感冒了 B-->>A: 感冒了:( else 很好 B-->>A: 吃嘛嘛香:) end end rect rgba(255,0,255) opt 额外的响应 B-->>A: 谢谢关心！ end end 类图（Class） The class diagram is the main building block of object-oriented modeling. It is used for general conceptual modeling of the structure of the application, and for detailed modeling translating the models into programming code. Class diagrams can also be used for data modeling. The classes in a class diagram represent both the main elements, interactions in the application, and the classes to be programmed. 类图是面向对象建模的主要构件。它用于应用程序结构的一般概念建模，以及将模型转换为编程代码的详细建模。类图也可以用于数据建模。类图中的类表示主要元素、应用程序中的交互以及要编程的类。 12345678910111213141516171819202122232425262728293031classDiagram Animal &lt;|-- Duck Animal &lt;|-- Fish Animal &lt;|-- Zebra Animal : +int age Animal : +String gender Animal: +isMammal() Animal: +mate() class Duck&#123; +String beakColor +swim() +quack() &#125; class Fish&#123; -int sizeInFeet -canEat() &#125; class Zebra&#123; +bool is_wild +run() &#125; %% Generic Types class Square~Shape~&#123; int id List~Integer~ position setPoints(List~Integer~ points) getPoints() List~Integer~ &#125; Square:-List~String~ message Square:+setMessage(List~String~ message) Square:+getMessage() List~String~ classDiagram Animal ClassF:关联 ClassG ..> ClassH:依赖 ClassG1 .. ClassH1:双向依赖 ClassI ..* ClassJ:组合 ClassK --o ClassL:聚合 状态图（State） A state diagram is a type of diagram used in computer science and related fields to describe the behavior of systems. State diagrams require that the system described is composed of a finite number of states; sometimes, this is indeed the case, while at other times this is a reasonable abstraction. 状态图是计算机科学和相关领域中用来描述系统行为的一种图。状态图要求所描述的系统由有限个状态组成；有时，情况确实如此，而有时这是一种合理的抽象。 12345678stateDiagram-v2 [*] --&gt; Still Still --&gt; [*]:transition Still --&gt; Moving Moving --&gt; Still Moving --&gt; Crash Crash --&gt; [*] stateDiagram-v2 [*] --> Still Still --> [*]:transition Still --> Moving Moving --> Still Moving --> Crash Crash --> [*] 123stateDiagram-v2 state &quot;hello&quot; as s1 s2:hello stateDiagram-v2 state \"hello\" as s1 s2:hello 12graph LR A-.-|hello|B graph LR A-.-|hello|B 123456789101112131415stateDiagram-v2 [*] --&gt; First state First &#123; [*] --&gt; Second state Second &#123; [*] --&gt; second second --&gt; Third state Third &#123; [*] --&gt; third third --&gt; [*] &#125; &#125; &#125; stateDiagram-v2 [*] --> First state First { [*] --> Second state Second { [*] --> second second --> Third state Third { [*] --> third third --> [*] } } } 1234567891011121314151617stateDiagram-v2 [*] --&gt; First First --&gt; Second First --&gt; Third state First &#123; [*] --&gt; fir fir --&gt; [*] &#125; state Second &#123; [*] --&gt; sec sec --&gt; [*] &#125; state Third &#123; [*] --&gt; thi thi --&gt; [*] &#125; stateDiagram-v2 [*] --> First First --> Second First --> Third state First { [*] --> fir fir --> [*] } state Second { [*] --> sec sec --> [*] } state Third { [*] --> thi thi --> [*] } 1234567891011stateDiagram-v2 state fork_state &lt;&lt;fork&gt;&gt; [*] --&gt; fork_state fork_state --&gt; State2 fork_state --&gt; State3 state join_state &lt;&lt;join&gt;&gt; State2 --&gt; join_state State3 --&gt; join_state join_state --&gt; State4 State4 --&gt; [*] stateDiagram-v2 state fork_state [*] --> fork_state fork_state --> State2 fork_state --> State3 state join_state State2 --> join_state State3 --> join_state join_state --> State4 State4 --> [*] 12345678stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --&gt; State2 note left of State2 : This is the note to the left. stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --> State2 note left of State2 : This is the note to the left. 12345678910111213141516stateDiagram-v2 [*] --&gt; Active state Active &#123; [*] --&gt; NumLockOff NumLockOff --&gt; NumLockOn : EvNumLockPressed NumLockOn --&gt; NumLockOff : EvNumLockPressed -- [*] --&gt; CapsLockOff CapsLockOff --&gt; CapsLockOn : EvCapsLockPressed CapsLockOn --&gt; CapsLockOff : EvCapsLockPressed -- [*] --&gt; ScrollLockOff ScrollLockOff --&gt; ScrollLockOn : EvScrollLockPressed ScrollLockOn --&gt; ScrollLockOff : EvScrollLockPressed &#125; stateDiagram-v2 [*] --> Active state Active { [*] --> NumLockOff NumLockOff --> NumLockOn : EvNumLockPressed NumLockOn --> NumLockOff : EvNumLockPressed -- [*] --> CapsLockOff CapsLockOff --> CapsLockOn : EvCapsLockPressed CapsLockOn --> CapsLockOff : EvCapsLockPressed -- [*] --> ScrollLockOff ScrollLockOff --> ScrollLockOn : EvScrollLockPressed ScrollLockOn --> ScrollLockOff : EvScrollLockPressed } 实体关系图（Entity Relationship） An entity–relationship model (or ER model) describes interrelated things of interest in a specific domain of knowledge. A basic ER model is composed of entity types (which classify the things of interest) and specifies relationships that can exist between entities (instances of those entity types). 实体-关系模型（或ER模型）描述特定知识领域中相关的事物。基本ER模型由实体类型（对感兴趣的事物进行分类）组成，并指定实体之间可能存在的关系（这些实体类型的实例）。 1234erDiagram CUSTOMER ||--o&#123; ORDER : places ORDER ||--|&#123; LINE-ITEM : contains CUSTOMER &#125;|..|&#123; DELIVERY-ADDRESS : uses erDiagram CUSTOMER ||--o{ ORDER : places ORDER ||--|{ LINE-ITEM : contains CUSTOMER }|..|{ DELIVERY-ADDRESS : uses Relationship Relationship Description o| Zero or one || Exactly one o{ Zero or more |{ One or more 用户体验图（User Journey） User journeys describe at a high level of detail exactly what steps different users take to complete a specific task within a system, application or website. This technique shows the current (as-is) user workflow, and reveals areas of improvement for the to-be workflow. 用户旅程详细地描述了不同用户在系统、应用程序或网站中完成特定任务所采取的步骤。这项技术显示了当前（原样）用户工作流，并揭示了未来工作流的改进领域。 123456789journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me journey title My working day section Go to work Make tea: 5: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me 甘特图（Gantt） A Gantt chart is a type of bar chart, first developed by Karol Adamiecki in 1896, and independently by Henry Gantt in the 1910s, that illustrates a project schedule and the amount of time it would take for any one project to finish. Gantt charts illustrate number of days between the start and finish dates of the terminal elements and summary elements of a project. 甘特图是一种条形图，由Karol Adamiecki于1896年首次开发，由Henry Gantt于1910年独立开发，用于说明项目进度和任何一个项目完成所需的时间。甘特图显示了项目的终端元素和摘要元素的开始日期和完成日期之间的天数。 1234567891011121314151617181920212223242526272829gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid excludes weekends %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week (&quot;sunday&quot;) or &quot;weekends&quot;, but not the word &quot;weekdays&quot;.) section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h gantt dateFormat YYYY-MM-DD title Adding GANTT diagram functionality to mermaid excludes weekends %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week (\"sunday\") or \"weekends\", but not the word \"weekdays\".) section A section Completed task :done, des1, 2014-01-06,2014-01-08 Active task :active, des2, 2014-01-09, 3d Future task : des3, after des2, 5d Future task2 : des4, after des3, 5d section Critical tasks Completed task in the critical line :crit, done, 2014-01-06,24h Implement parser and jison :crit, done, after des1, 2d Create tests for parser :crit, active, 3d Future task in critical line :crit, 5d Create tests for renderer :2d Add to mermaid :1d section Documentation Describe gantt syntax :active, a1, after des1, 3d Add gantt diagram to demo page :after a1 , 20h Add another diagram to demo page :doc1, after a1 , 48h section Last section Describe gantt syntax :after doc1, 3d Add gantt diagram to demo page :20h Add another diagram to demo page :48h 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B 12graph LR A-.-|hello|B graph LR A-.-|hello|B","categories":[{"name":"tool","slug":"tool","permalink":"https://yclii.github.io/workbook/categories/tool/"}],"tags":[{"name":"mermaid","slug":"mermaid","permalink":"https://yclii.github.io/workbook/tags/mermaid/"}]},{"title":"git学习笔记","slug":"git学习笔记","date":"2021-05-20T15:16:25.000Z","updated":"2021-10-27T11:13:08.609Z","comments":true,"path":"2021/05/20/git学习笔记/","link":"","permalink":"https://yclii.github.io/workbook/2021/05/20/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"概述开源的分布式版本控制系统 历史","categories":[{"name":"devOpts","slug":"devOpts","permalink":"https://yclii.github.io/workbook/categories/devOpts/"}],"tags":[{"name":"git","slug":"git","permalink":"https://yclii.github.io/workbook/tags/git/"}]},{"title":"AWR报告解析","slug":"AWR报告解析","date":"2021-05-10T23:00:08.000Z","updated":"2021-10-27T11:13:08.609Z","comments":true,"path":"2021/05/10/AWR报告解析/","link":"","permalink":"https://yclii.github.io/workbook/2021/05/10/AWR%E6%8A%A5%E5%91%8A%E8%A7%A3%E6%9E%90/","excerpt":"","text":"概述1997-06: ECMAScript 1First edition. 1998-06: ECMAScript 2","categories":[{"name":"oracle","slug":"oracle","permalink":"https://yclii.github.io/workbook/categories/oracle/"}],"tags":[{"name":"oracle","slug":"oracle","permalink":"https://yclii.github.io/workbook/tags/oracle/"},{"name":"AWR","slug":"AWR","permalink":"https://yclii.github.io/workbook/tags/AWR/"}]},{"title":"vscode开发vue的配置与插件","slug":"vscode开发vue的配置与插件","date":"2021-05-10T02:36:36.000Z","updated":"2021-10-27T11:13:08.611Z","comments":true,"path":"2021/05/09/vscode开发vue的配置与插件/","link":"","permalink":"https://yclii.github.io/workbook/2021/05/09/vscode%E5%BC%80%E5%8F%91vue%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%8F%92%E4%BB%B6/","excerpt":"","text":"概述介绍用vscode开发vue程序的相关配置与辅助插件 配置 vue代码片段模板 ctrl+shift+p，打开命令窗口，输入Snippets，出现下图： 输入vue，选择vue.code-snippets： 会在当前项目根目录中生成.vscode/vue.code-snippets文件，在文件中添加以下内容： 123456789101112131415161718192021222324252627282930313233&quot;vue&quot;: &#123; &quot;prefix&quot;: &quot;vue&quot;, &quot;body&quot;: [ &quot;&lt;!--&quot;, &quot;* @description $1&quot;, &quot;* @fileName $TM_FILENAME&quot;, &quot;* @author ycli&quot;, &quot;* @date $CURRENT_YEAR/$CURRENT_MONTH/$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND&quot;, &quot;!--&gt;&quot;, &quot;&lt;template&gt;&quot;, &quot; &lt;div&gt;$0&lt;/div&gt;&quot;, &quot;&lt;/template&gt;&quot;, &quot;&quot;, &quot;&lt;script&gt;&quot;, &quot;export default &#123;&quot;, &quot; data () &#123;&quot;, &quot; return &#123;&quot;, &quot; &#125;&quot;, &quot; &#125;,&quot;, &quot;&quot;, &quot; components: &#123;&#125;,&quot;, &quot;&quot;, &quot; computed: &#123;&#125;,&quot;, &quot;&quot;, &quot; mounted: &#123;&#125;,&quot;, &quot;&quot;, &quot; methods: &#123;&#125;&quot;, &quot;&#125;&quot;, &quot;&quot;, &quot;&lt;/script&gt;&quot;, ], &quot;description&quot;: &quot;vue初始化页面&quot; &#125; 新建.vue的文件，在文件中输入vue（对应上面配置属性preffix），回车： 插件 vetur 功能：语法高亮 vue 3 snippets 功能：基于最新的 Vue 2 及 Vue 3 的 API 添加了 Code Snippets element ui Snippets 功能：通过快捷代码快速制定element-ui组件代码片段，如输入elt，回车后会自动生成el-table节点","categories":[{"name":"vscode","slug":"vscode","permalink":"https://yclii.github.io/workbook/categories/vscode/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://yclii.github.io/workbook/tags/vscode/"},{"name":"vue","slug":"vue","permalink":"https://yclii.github.io/workbook/tags/vue/"}]},{"title":"maven学习笔记","slug":"maven学习笔记","date":"2021-05-10T01:37:18.000Z","updated":"2021-10-27T11:13:08.610Z","comments":true,"path":"2021/05/09/maven学习笔记/","link":"","permalink":"https://yclii.github.io/workbook/2021/05/09/maven%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"概述maven是一个项目管理工具，包含了一个项目对象模型（POM，project object model）、一组标准集合（遵循约定优于配置[COC，conversion over configuration]原则，规定了一些规范，如项目目录规范、变量规范、版本规范等）、一个项目声明周期、一个依赖管理，以及运行定义在声明周期阶段（phase）中插件（plugin）的目标（goal）中的逻辑。 安装 准备资源 win7、jdk8、maven3.x、eclipse POM遵循的约定依赖管理生命周期多模块与继承Profile属性和资源过滤套件站点nexusm2eclipse手写插件参考资料 maven权威指南","categories":[{"name":"maven","slug":"maven","permalink":"https://yclii.github.io/workbook/categories/maven/"}],"tags":[{"name":"maven","slug":"maven","permalink":"https://yclii.github.io/workbook/tags/maven/"}]},{"title":"vue学习笔记","slug":"vue学习笔记","date":"2021-05-09T22:36:19.000Z","updated":"2021-10-27T11:13:08.611Z","comments":true,"path":"2021/05/09/vue学习笔记/","link":"","permalink":"https://yclii.github.io/workbook/2021/05/09/vue%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"概述MVVM安装 准备资源 win7、node、vue2.x、element-ui Vue实例指令计算属性数组更新表单与v-model组件参考文档 vue中文官网文档 vue.js实战.梁灏 vue.js项目开发实战.张帆","categories":[{"name":"vue","slug":"vue","permalink":"https://yclii.github.io/workbook/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://yclii.github.io/workbook/tags/vue/"}]},{"title":"mysql源码安装","slug":"mysql源码安装","date":"2021-05-09T18:30:03.000Z","updated":"2021-10-27T11:13:08.610Z","comments":true,"path":"2021/05/09/mysql源码安装/","link":"","permalink":"https://yclii.github.io/workbook/2021/05/09/mysql%E6%BA%90%E7%A0%81%E5%AE%89%E8%A3%85/","excerpt":"","text":"概述实现mysql的源码安装 安装 准备资源 win7、mysql8 资源下载 https://dev.mysql.com/downloads/mysql/ 配置文件 将压缩包解压到磁盘目录，并在系统环境变量中添加变量Mysql_HOME，并添加%Mysql_HOME%\\bin;到环境变量Path中。 在安装目录下，新建my.ini文件，并添加如下内容： 12345678910111213141516171819202122232425262728293031323334353637383940# 客户端设置 [mysql]default-character-set=utf8mb4 # 服务端设置 [mysqld]# 端口port=3306# 设置mysql的安装目录basedir=&quot;F:/mysql-8.0.23&quot;# 数据保存位置datadir=&quot;F:/mysql-8.0.23/data&quot;# 允许最大连接数max_connections=100# 允许连接失败的次数。这是为了防止有人从该主机试图攻击数据库系统max_connect_errors=3# 服务端使用的字符集默认为UTF8（UTF8MB3）character-set-server=utf8mb4# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password 说明：根据自己的安装目录，更改basedir和datadir；在mysql编码中，utf8mb4才是真正的utf-8，用4个字节存储中文。 启动服务 123456789# 初始化# 此处会给出root的初始化密码（暂存，后面有用）mysqld --initialize --console# 安装mysqlmysqld --install# windows启动mysql服务，停止：net stop mysql;删除：mysqld -remove mysqlnet start mysql# 查看windows服务启动状况services.msc 初始化root密码 1234# 输入刚才的密码mysql -u root -p# 修改root密码alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;新密码&#x27;; 问题及解决方法 运行mysqld --install，报“无法启动此程序，因为计算机丢失VCRUNTIME140_1.dll。” 下载一个微软常用运行库合集，运行一下即可。安装包在百度云盘中。 navicat for mysql 15破解 准备资源 下载navicat for mysql 15 官网地址：http://www.navicat.com.cn/download/navicat-for-mysql 下载注册机 百度网盘：Navicat Keygen Patch v5.6.0 DFoX.exe 破解步骤 安装navicat for mysql，确认安装目录后，一直根据提示确认即可。 将注册机文件复制到navicat for mydql的安装目录 打开注册机： 待续。。。","categories":[{"name":"mysql","slug":"mysql","permalink":"https://yclii.github.io/workbook/categories/mysql/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://yclii.github.io/workbook/tags/mysql/"}]},{"title":"信贷核算晚间批量性能优化思路分享","slug":"信贷核算晚间批量性能优化思路分享","date":"2021-05-07T12:34:42.000Z","updated":"2021-10-27T11:13:08.611Z","comments":true,"path":"2021/05/07/信贷核算晚间批量性能优化思路分享/","link":"","permalink":"https://yclii.github.io/workbook/2021/05/07/%E4%BF%A1%E8%B4%B7%E6%A0%B8%E7%AE%97%E6%99%9A%E9%97%B4%E6%89%B9%E9%87%8F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF%E5%88%86%E4%BA%AB/","excerpt":"","text":"信贷核算晚间批量性能优化思路分享 交付一总部 | 李一称 2021.05 [toc] 项目背景系统名称：XX银行零售信贷系统 系统特性：拥有独立核算功能 业务数据：基础业务数据单表百万级 晚间批量：Java程序，公司批量框架，日批 软件版本：JDK7、Oracle11g、ALS7 运行状况：晚间批量整体执行耗时超过允许的最大阈值范围（晚10点-明早7点） 优化目标现状：晚间批量整体运行结束时间超过了早上7点 目标：晚间批量整体运行结束时间控制在在凌晨5点之前 优化对象因晚间批量为日批，且每天都表现的很慢，就抓取了昨晚的批量任务单元执行日志表（AWE_TASK_INFO，主要包括任务单元编号、名称、开始时间、结束时间等）中的执行时长，快速筛选大于阈值（10 min）的任务单元，计划为本次优化的对象。当时排在TOP5的单元都在30min以上，且TOP1的耗时达到了近90min。 代码分析说明：文档中涉及的代码（包括类名）均为伪代码，但可以表达出实际项目的大致实现。 所有的任务单元处理类均继承了AbstractLoanTask.java，该类采用了模板方法的设计模式，基本结构及实现逻辑如下： 1234567891011121314151617181920212223242526272829303132333435363738/*** 执行入口*/public int execute() throws Exception &#123; try &#123; before(); run(); after(); &#125; catch (Exception e) &#123; //异常处理、日志记录 ... &#125; finally &#123; //资源释放 ... &#125; &#125;/*** 1、初始化当前实例业务属性* 2、初始化数据库连接* 3、初始化当前任务单元执行日志开始信息*/public void before() throws Exception &#123; ...&#125;/*** 业务处理主体，待具体单元实现*/public abstract void run() throws Exception;/*** 业务处理后续逻辑，如更新当前任务单元执行日志结束信息*/public void after() throws Exception &#123; ...&#125; 数据访问层做了一个基类（BasicDao.java）的封装，实现的公共功能大致有： 方法 说明 BizObject findObjectByKey(DataElement key) 根据业务主键获取业务对象 List&lt;BizObject&gt; findObjectsByObjectNo(DataElement objectNo) 根据关联对象编号获取业务对象集合 当然还有一些更新的方法 持久层做了一个Model基类（BasicModel）,包含的属性大致有： 属性 说明 BizObject value 当前业务对象 List&lt;BizObject&gt; relativeObjects 关联的业务对象 List&lt;BizObject&gt; deleteObjects 待删除的业务对象 List&lt;BizObject&gt; insertObjects 待保存的业务对象 List&lt;BizObject&gt; updateObjects 待更新的业务对象 在对当前业务对象及相关联对象进行保存或更新时，会依次解析deleteObjects、insertObjects、updateObjects成带有变量绑定的sql语句，如delete、insert、update语句。 晚间核算，如一般贷款还款批量（TOP1就是它）、提前还款批量，大致的数据流结构如下： 分析结果 单线程，无法获取多核cpu的计算效率。（linux系统通过top命令查看） 主表记录以及级联的业务记录均在jvm中实例化后参与核算，导致内存可能消耗会很快。 核算逻辑在java逻辑中，性能瓶颈很大可能在jvm优化层面上。 AWR报告分析 关注点 AWR报告采用总分的形式，前面是系统的整体情况，后面是各个部分细节，一开始不要陷入细节，先分析系统的整体状况，对于后面的专题分析，要根据关注点的不同，采取跳跃式分析。还要根据具体业务的不同，决定某种现象是否正常。 根据代码的分析，核算的业务逻辑大都是基于主表记录的迭代，通过关联流水号查询其相关的业务表记录。表现出大量相同sql的频繁执行，所以在分析AWR报告时可以关注以下几点： Load Profile：了解系统整体负载状况，如每秒中的事务数/语句数，每秒/每事务物理读写次数(Physical Reads/Writes), 逻辑读写次数(Logical Reads/Writes)，SQL语句的解析(Parse)，特别是硬解析的次数（per second或per transaction），硬解析太多，说明SQL重用率不高，一般是应用程序sql没有做变量绑定处理。 Instance Efficiency Percentages： 各指标都应接近100%，如： Library Hit 表示从Library Cache中检索到一个解析过的SQL或PL/SQL语句的比率，当应用程序调用SQL或存储过程时，Oracle检查Library Cache确定是否存在解析过的版本，如果存在，Oracle立即执行语句；如果不存在，Oracle解析此语句，并在Library Cache中为它分配共享SQL区。低的library hit ratio会导致过多的解析，增加CPU消耗，降低性能。如果library hit ratio低于90%，可能需要调大shared pool区。 Latch Hit Latch是一种保护内存结构的轻量级锁，可以认为是进程获取访问内存数据结构的许可。要确保Latch Hit&gt;99%，否则意味着Shared Pool latch争用，可能由于未共享的SQL，或者Library Cache太小，可使用绑定变更或调大Shared Pool解决。 Top 5 Timed Events： 这里列出消耗时间最多的5个等待事件，每种等待说明，都表示一种原因，如：db file sequential read表示按索引（索引选择性差）访问出现等待；db file scattered read表示全表扫描访问出现等待事件；db file parallel write 表示I/O负载高，可以通过设置db_writer_processes来提高DBWR进程数量。 TopNSQL： 根据时间消耗，内存消耗，物理I/O等排序，对相关SQL分析执行计划。 生成AWR报告 sqlplus / as sysdba @?/rdbms/admin/awrrpt.sql 输入 html –这是选择awr的查看方式网页方式（默认）或者txt 输入天数 –一般是1-8的数字，1就代表当天的（Oracle10g默认保留7天快照、11g默认保留8天快照，但可以手工设置） 输入开始快照ID 输入结束快照ID 输入保存文件名称 –例如 awr-20210101.html 回车 分析结果 因核算代码数据访问层对sql进行了统一的转换和处理，且做了变量绑定，一般硬解析次数会很正常；sql查询或更新都是根据相关流水号做的单张表单条记录的更新，一般流水号字段都会添加索引，个人认为数据库优化的空间不大，除了一些数据库硬件瓶颈。 JVM内存分析 关注点 因对cpu的使用不够，初步采用多线程设计势在必行。但是，设置多少个线程合适？因核算逻辑集中的java代码中处理，每个业务对象及其关联的业务对象都会被实例化一个个对象，且为了满足业务对象的普适性，一般都会做“select * from T”，即查询所有字段。本来就会消耗了“多余”的内存，这时候再做多线程处理，若线程数设置的不合理，会直接导致内存的快速增长，OOM现象会很容易出现。 此时，需要关注以下3个要素，以达到平衡： Xmx 进程的最大堆内存 Pagesize 进程处理的主表业务记录数 Threads 线程数 内存模型 方法区（线程共享） 被所有方法线程共享的一块内存区域。用于存储已经被虚拟机加载的类信息，常量，静态变量等。这个区域的内存回收目标主要针对常量池的回收和堆类型的卸载。 堆（线程共享） 被所有线程共享的一块内存区域，在虚拟机启动的时候创建，用于存放对象实例。当堆中没有内存可分配给实例，也无法再扩展时，则抛出OutOfMemoryError异常。 Java栈（线程私有） 每个方法在执行的时候也会创建一个栈帧，存储了局部变量，操作数，动态链接，方法返回地址。每个方法从调用到执行完毕，对应一个栈帧在虚拟机栈中的入栈和出栈。通常所说的栈，一般是指在虚拟机栈中的局部变量部分。如果线程请求的栈深度大于虚拟机所允许的深度，则抛出StackOverflowError异常。 本地方法栈（线程私有） 和Java栈类似，主要为虚拟机使用到的Native方法服务。也会抛出StackOverflowError 异常。 程序计数器（线程私有） 执行Java方法时，计数器记录的是虚拟机字节码指令的地址(当前指令的地址)。 堆分代 几乎所有的Java对象实例都放在Java堆中。这也就意味着，堆中对象分配和回收将是JVM的处理重点！为了更好的处理这些对象，JVM便将Java堆分成几块区域。由于根据对象存活的周期不同，所以称之为新生代、老年代和永久代（JDK1.8起被移除，添加了元空间的概念）。 新生代内存按照8:1:1的比例分为一个eden区和两个survivor区。大部分对象在eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。 当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。 说明：参数均可以调整，默认参数可以用java -XX:+PrintFlagsInitial查看 分析工具jstat 可以实时监控堆的使用情况： 查看新生代、老生代及元空间的容量及使用情况 查看新生代、老生代及元空间的垃圾收集情况，包括垃圾回收的次数及垃圾回收所占用的时间 gc实时统计命令： jstat -gcutil 进程ID 3000 列名 说明 S0 Heap上的 Survivor space 0 区已使用空间的百分比 S1 Heap上的 Survivor space 1 区已使用空间的百分比 E Heap上的 Eden space 区已使用空间的百分比 O Heap上的 Old space 区已使用空间的百分比 M Metaspace 区已使用空间的百分比 CCS 压缩类空间的百分比 YGC 从应用程序启动到采样时发生 Young GC 的次数 YGCT 从应用程序启动到采样时 Young GC 所用的时间(单位秒) FGC 从应用程序启动到采样时发生 Full GC 的次数 FTCT 从应用程序启动到采样时 Full GC 所用的时间(单位秒) GCT 从应用程序启动到采样时用于垃圾回收的总时间(单位秒)，它的值等于YGC+FGC 参数调整 已知Xmx=2048M，PageSize=2000，业务数据来源于模拟生产数据量，以减少FGC、FTCT，GCT为目的，多次测试，取得优化后的线程数Threads。此外，多进程的配合，可以强迫式减少GC时间，这取决于初始化一个虚拟机进程以及内部相关初始化服务付出的时间代价与后期GC时间的权衡。一般的，晚间批量进程服务少，启动都很快，可以考虑支持多进程。 优化思路 增加多进程多线程代码增强处理，提高应用cpu利用率。 借助jstat工具调整配置参数，避免频繁的gc。 借助AWR报告，找出是否有明显的性能瓶颈。 多进程多线程 MPMT（Multiple Progresses Multiple Threads）流程图 基类AbstractLoanTask代码增强 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * 批处理基类 */public abstract class AbstractTaskBatch extends ExecuteUnit &#123; //执行状态 protected AtomicInteger executeStatus = new AtomicInteger(TaskConstants.ES_SUCCESSFUL); //主表查询sql protected String querySql; //是否多进程 protected boolean multiProgresses; //是否多线程 protected boolean multiThreads; //初始化进程数 protected int progresses; //每个进程分配的业务记录数 protected int pageSize; //每个进程分配的堆内存（单位M） protected int xmx; ... /** * 多线程业务处理 * @param valuePools 参数池 * @param group 线程组 * @param thread 处理线程 * @throws Exception */ protected void executeBatchThread(ASValuePool[] valuePools,ThreadGroup group,BatchThread thread) throws Exception &#123; if(!ArrayUtils.isEmpty(valuePools))&#123; if(this.multiThreads &amp;&amp; this.threadsPerProgress &gt;0 &amp;&amp; valuePools.length &gt; 1)&#123; for(ASValuePool valuePool:valuePools)&#123; BatchThread clone = (BatchThread)thread.clone(); clone.valuePool = valuePool; new Thread(group,clone).start(); &#125; while(group.activeCount() &gt;0)&#123; //halt 表示线程组存在失败的线程是否终其他线程的执行 if(this.halt &amp;&amp; this.executeStatus.get() == TaskConstants.ES_FAILED)&#123; group.interrupt(); &#125; &#125; &#125;else&#123; for(ASValuePool valuePool:valuePools)&#123; thread.valuePool = valuePool; thread.run(); &#125; &#125; &#125; &#125; /** * 多线程处理器 */ protected abstract class BatchThread implements Runnable,Cloneable &#123; //输入参数 public ASValuePool valuePool; @Override protected Object clone() throws CloneNotSupportedException &#123; // TODO Auto-generated method stub return super.clone(); &#125; @Override public void run() &#123; // TODO Auto-generated method stub Connection connection = null; try &#123; ARE.getDBConnection(database); execute(connection); &#125; catch (Throwable t) &#123; executeStatus.set(TaskConstants.ES_FAILED); ARE.getLog().error(&quot;Thread[&quot; + this.getName() + &quot;] execute error&quot;, t); &#125;finally&#123; if(connection != null) connection.close(); &#125; &#125; public abstract void execute(Connection connection) throws Throwable; &#125; &#125; shell脚本 1234567891011121314151617181920212223242526272829303132#!/bin/shtask=$1target=$2unit=$3range=$4xmx=$5if [ -z &quot;$xmx&quot; ]; then xmx=1024ficd `dirname $0`export LANG=zh_CN.UTF-8if [ -z &quot;$JAVA_HOME&quot; ]; then echo &quot;environment variable JAVA_HOME missed,please check!&quot; exit 1ficd ..CLASSPATH=.$&#123;JAVA_HOME&#125;/jre/lib/rt.jar:./classesJLIBDIR=./libexport JLIBDIRfor LL in `ls $JLIBDIR/*.jar`do CLASSPATH=$CLASSPATH:$LLdoneexport CLASSPATHexport JAVA_OPTION=&quot;-Dfile.encoding=UTF-8 -xms$&#123;xmx&#125;M -Xmx$&#123;xmx&#125;M&quot;export RUN_CLASS=com.amarsoft.task.SlaveProgressExecutortaskInfo=&quot;task=$&#123;task&#125; target=$&#123;target&#125; unit=$&#123;unit&#125; range=$&#123;range&#125;&quot;i=`$&#123;JAVA_HOME&#125;/bin/java $&#123;JAVA_OPTION&#125; -classpath $&#123;CLASSPATH&#125; $&#123;RUN_CLASS&#125; $&#123;taskInfo&#125;`exit i 从进程任务执行器，SlaveProgressExecutor.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void main(String[] args) &#123; CommandLineArgument arguments = new CommandLineArgument(args); String are = arguments.getArgument(&quot;are&quot;); if (are != null) ARE.init(are); else ARE.init(); String taskFile = arguments.getArgument(&quot;task&quot;, ARE.getProperty(&quot;taskFile&quot;)); notNull(taskFile,&quot;没有定义任务配置文件！&quot;); String sTarget = arguments.getArgument(&quot;target&quot;); notNull(sTarget,&quot;没有定义target参数！&quot;); String sUnit = arguments.getArgument(&quot;unit&quot;); notNull(sUnit,&quot;没有定义unit参数！&quot;); Task task = TaskBuilder.buildTaskFromXML(taskFile); notNull(task,&quot;创建任务失败！&quot;); Target target = task.getTarget(sTarget); notNull(task,&quot;获取target失败！&quot;); ExecuteUnit unit = target.getUnit(sUnit); notNull(unit,&quot;获取unit失败！&quot;); //业务数据范围，格式：A~#~B unit.setProperty(&quot;multi.range&quot;, arguments.getArgument(&quot;range&quot;)); //标识当前进程为从进程 unit.setProperty(&quot;multi.slave&quot;, &quot;true&quot;); //status 成功返回0 失败返回1 int status = unit.execute(); if(status == TaskConstants.ES_SUCCESSFUL) status = 0; else status = 1; System.exit(status);&#125; /** * 对象为空处理 * * @param object * @param message*/private static void notNull(Object object,String message) &#123; if(object == null) &#123; ARE.getLog().error(message); System.exit(1);//执行失败，返回码1 &#125;&#125; 项目总结 从工程代码结构出发，快速抓住了性能瓶颈（cpu资源利用不足）。 对代码进行了横切增强，更重要的是没有对核算逻辑（不敢动）造成侵害。 考虑到了gc因素，通过gc监控，使参数达到最优，且参数均可配置，建议后期维护可以定期收集gc统计日志，对应调整参数。 优化的还算成功，top1的一般还款由原先的90min降到了10min以内。 这是我的第一个性能优化类项目，肯定有没有考虑周全的地方，日后发现改进补充。 st=>start: 开始 op=>operation: 获取主表（如借据表）结果集并遍历 op2=>operation: 遍历中获取每条主表记录并级联获取关联对象，多级关联。 op3=>operation: 执行具体核算逻辑更新相关业务对象及数据库表记录 e=>end: 结束 st->op op->op2 op2->op3 op3->e{\"theme\":\"simple\",\"scale\":1,\"line-width\":2,\"line-length\":50,\"text-margin\":10,\"font-size\":12} var code = document.getElementById(\"flowchart-0-code\").value; var options = JSON.parse(decodeURIComponent(document.getElementById(\"flowchart-0-options\").value)); var diagram = flowchart.parse(code); diagram.drawSVG(\"flowchart-0\", options);","categories":[{"name":"性能优化","slug":"性能优化","permalink":"https://yclii.github.io/workbook/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"AWR","slug":"AWR","permalink":"https://yclii.github.io/workbook/tags/AWR/"},{"name":"JVM","slug":"JVM","permalink":"https://yclii.github.io/workbook/tags/JVM/"},{"name":"多进程","slug":"多进程","permalink":"https://yclii.github.io/workbook/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"},{"name":"多线程","slug":"多线程","permalink":"https://yclii.github.io/workbook/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]}],"categories":[{"name":"HTTPS","slug":"HTTPS","permalink":"https://yclii.github.io/workbook/categories/HTTPS/"},{"name":"devOpts","slug":"devOpts","permalink":"https://yclii.github.io/workbook/categories/devOpts/"},{"name":"tool","slug":"tool","permalink":"https://yclii.github.io/workbook/categories/tool/"},{"name":"oracle","slug":"oracle","permalink":"https://yclii.github.io/workbook/categories/oracle/"},{"name":"vscode","slug":"vscode","permalink":"https://yclii.github.io/workbook/categories/vscode/"},{"name":"maven","slug":"maven","permalink":"https://yclii.github.io/workbook/categories/maven/"},{"name":"vue","slug":"vue","permalink":"https://yclii.github.io/workbook/categories/vue/"},{"name":"mysql","slug":"mysql","permalink":"https://yclii.github.io/workbook/categories/mysql/"},{"name":"性能优化","slug":"性能优化","permalink":"https://yclii.github.io/workbook/categories/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"SSL,TLS,OpenSSL","slug":"SSL-TLS-OpenSSL","permalink":"https://yclii.github.io/workbook/tags/SSL-TLS-OpenSSL/"},{"name":"docker","slug":"docker","permalink":"https://yclii.github.io/workbook/tags/docker/"},{"name":"mermaid","slug":"mermaid","permalink":"https://yclii.github.io/workbook/tags/mermaid/"},{"name":"git","slug":"git","permalink":"https://yclii.github.io/workbook/tags/git/"},{"name":"oracle","slug":"oracle","permalink":"https://yclii.github.io/workbook/tags/oracle/"},{"name":"AWR","slug":"AWR","permalink":"https://yclii.github.io/workbook/tags/AWR/"},{"name":"vscode","slug":"vscode","permalink":"https://yclii.github.io/workbook/tags/vscode/"},{"name":"vue","slug":"vue","permalink":"https://yclii.github.io/workbook/tags/vue/"},{"name":"maven","slug":"maven","permalink":"https://yclii.github.io/workbook/tags/maven/"},{"name":"mysql","slug":"mysql","permalink":"https://yclii.github.io/workbook/tags/mysql/"},{"name":"JVM","slug":"JVM","permalink":"https://yclii.github.io/workbook/tags/JVM/"},{"name":"多进程","slug":"多进程","permalink":"https://yclii.github.io/workbook/tags/%E5%A4%9A%E8%BF%9B%E7%A8%8B/"},{"name":"多线程","slug":"多线程","permalink":"https://yclii.github.io/workbook/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}]}